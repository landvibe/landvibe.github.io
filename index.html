<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ë°”ë‹¤ í•€ë³¼ - Ocean Pinball Roguelike</title>
<!-- PWA -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#4682B4">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="ë°”ë‹¤ í•€ë³¼">
<link rel="apple-touch-icon" href="./icon-192.png">
<link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="./icon-512.png">
<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="ë°”ë‹¤ í•€ë³¼ - Ocean Pinball Roguelike">
<meta property="og:description" content="ê·€ì—¬ìš´ ë°”ë‹¤ ìƒë¬¼ ë²”í¼ì™€ í•¨ê»˜í•˜ëŠ” ë¡œê·¸ë¼ì´í¬ í•€ë³¼! ë¼ìš´ë“œë¥¼ í´ë¦¬ì–´í•˜ê³ , ìƒì ì—ì„œ ê°•í™”í•˜ê³ , ë‹¤ì–‘í•œ ëŠ¥ë ¥ì˜ ê³µì„ ë½‘ì•„ë³´ì„¸ìš”.">
<meta property="og:image" content="./icon-512.png">
<meta property="og:image:width" content="512">
<meta property="og:image:height" content="512">
<meta property="og:locale" content="ko_KR">
<!-- Twitter Card -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ë°”ë‹¤ í•€ë³¼ - Ocean Pinball Roguelike">
<meta name="twitter:description" content="ê·€ì—¬ìš´ ë°”ë‹¤ ìƒë¬¼ ë²”í¼ì™€ í•¨ê»˜í•˜ëŠ” ë¡œê·¸ë¼ì´í¬ í•€ë³¼! ë¼ìš´ë“œë¥¼ í´ë¦¬ì–´í•˜ê³ , ìƒì ì—ì„œ ê°•í™”í•˜ê³ , ë‹¤ì–‘í•œ ëŠ¥ë ¥ì˜ ê³µì„ ë½‘ì•„ë³´ì„¸ìš”.">
<meta name="twitter:image" content="./icon-512.png">
<!-- SEO -->
<meta name="description" content="ê·€ì—¬ìš´ ë°”ë‹¤ ìƒë¬¼ ë²”í¼ì™€ í•¨ê»˜í•˜ëŠ” ë¡œê·¸ë¼ì´í¬ í•€ë³¼! ë¼ìš´ë“œë¥¼ í´ë¦¬ì–´í•˜ê³ , ìƒì ì—ì„œ ê°•í™”í•˜ê³ , ë‹¤ì–‘í•œ ëŠ¥ë ¥ì˜ ê³µì„ ë½‘ì•„ë³´ì„¸ìš”.">
<meta name="keywords" content="í•€ë³¼, í•€ë³¼ ê²Œìž„, ë¡œê·¸ë¼ì´í¬, ë°”ë‹¤ í•€ë³¼, ocean pinball, ì›¹ ê²Œìž„, PWA ê²Œìž„">
<meta name="author" content="Ocean Pinball">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a1a; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
canvas { display: block; image-rendering: auto; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// ============================================================
//  CONSTANTS
// ============================================================
const WIDTH = 500, HEIGHT = 800;
const FPS = 60;
const GRAVITY = 0.18;
const BALL_R = 7;
const FLIP_LEN = 85;
const FLIP_W = 10;
const TABLE_L = 35;
const TABLE_R = 440;
const LANE_IN = 452;
const LANE_OUT = 490;
const MAX_SPEED = 28;

// Colors (Balatro Style - Sky Blue Theme)
const BALATRO_BG_BASE = [70, 130, 180];
const BALATRO_RED = [235, 65, 65];
const BALATRO_BLUE = [50, 100, 200];
const BALATRO_GOLD = [255, 180, 40];
const BALATRO_ORANGE = [255, 120, 40];
const BALATRO_PANEL = [30, 60, 100];
const BALATRO_DARK = [40, 80, 120];
const BALATRO_BORDER = [240, 240, 240];

const DEEP_SEA = [60, 120, 170];
const MID_SEA = BALATRO_BLUE;
const LIGHT_SEA = [120, 180, 240];
const SKY_SEA = [180, 215, 245];
const SURF_SEA = [220, 235, 250];
const WHITE = [245, 245, 245];
const BLACK = [20, 25, 40];
const PEARL = [235, 235, 240];
const PEARL2 = [210, 215, 230];

const PUFFER_Y = BALATRO_GOLD;
const PUFFER_D = BALATRO_ORANGE;
const JELLY_P = [255, 100, 255];
const JELLY_K = [200, 50, 200];
const JELLY_B = [100, 255, 255];
const CORAL_C = [255, 150, 130];
const CORAL_D = [255, 100, 80];
const SHELL_C = [255, 240, 220];
const SHELL_P = [255, 180, 180];
const FISH_COL = [BALATRO_RED, BALATRO_BLUE, BALATRO_GOLD, JELLY_P, JELLY_B];
const SEAWEED_C = [50, 200, 100];
const GOLD_C = BALATRO_GOLD;
const SCORE_C = WHITE;
const GLOW_C = [150, 220, 255];
const TREASURE_C = BALATRO_GOLD;

const ROUND_BASE_TARGET = 1500;
const ROUND_SCALE = 1000;
const GOLD_PER_ROUND = 4; // fixed base gold reward per round
const SHOP_BG = BALATRO_BG_BASE;
const SHOP_PANEL = [50, 50, 70];
const SHOP_HIGHLIGHT = [230, 230, 230];
const SHOP_MAX_C = [100, 220, 100];

// Table Walls
const WALLS = [
    [[TABLE_L, 80], [55, 35]],
    [[55, 35], [120, 12]],
    [[120, 12], [250, 8]],
    [[250, 8], [380, 12]],
    [[380, 12], [TABLE_R, 35]],
    [[TABLE_R, 35], [462, 55]],
    [[462, 55], [LANE_OUT, 100]],
    [[TABLE_R, 100], [TABLE_R, 685]],
    [[LANE_OUT, 100], [LANE_OUT, 770]],
    [[LANE_IN, 170], [LANE_IN, 770]],
    [[LANE_IN, 770], [LANE_OUT, 770]],
    [[TABLE_L, 80], [TABLE_L, 685]],
    [[TABLE_L, 685], [120, 740]],
    [[380, 740], [TABLE_R, 685]],
];

// ============================================================
//  SHOP ITEMS
// ============================================================
const SHOP_ITEMS = [
    {id:'flipper_power', name:'í”Œë¦¬í¼ ê°•í™”', desc:'í”Œë¦¬í¼ íž˜ +15%', max_lv:5, icon:'ðŸ’ª'},
    {id:'gravity', name:'ê°€ë²¼ìš´ ê³µ', desc:'ì¤‘ë ¥ -10%', max_lv:5, icon:'ðŸŽˆ'},
    {id:'score_boost', name:'ì ìˆ˜ ë¶€ìŠ¤íŠ¸', desc:'ê¸°ë³¸ ë°°ìœ¨ +0.2', max_lv:5, icon:'ðŸ“ˆ'},
    {id:'bumper_bonus', name:'ë²”í¼ ë³´ë„ˆìŠ¤', desc:'ë²”í¼ ì ìˆ˜ +30%', max_lv:5, icon:'ðŸ’¥'},
    {id:'flipper_size', name:'í° í”Œë¦¬í¼', desc:'í”Œë¦¬í¼ ê¸¸ì´ +5', max_lv:5, icon:'ðŸ“'},
];
const UPGRADE_DRAW_COST = 5;
const CONSUMABLE_DRAW_COST = 4;
const GACHA_COST = 5;
const RELIC_COST = 12;

const RELICS = [
    {id:'extra_box', name:'ê¹Šì€ ìƒìž', desc:'ì†Œëª¨í’ˆ ìŠ¬ë¡¯ +1', icon:'ðŸ“¦'},
    {id:'extra_life', name:'ìƒëª…ì˜ ì‚°í˜¸', desc:'ê¸°ë³¸ ìƒëª… +1', icon:'ðŸª¸'},
    {id:'gold_rush', name:'í™©ê¸ˆ ì¡°ê°œ', desc:'ë¼ìš´ë“œ ê¸°ë³¸ ê³¨ë“œ +2', icon:'ðŸš'},
    {id:'jelly_bounty', name:'í•´íŒŒë¦¬ ì™•ê´€', desc:'í•´íŒŒë¦¬ ê³¨ë“œ 2ë°°', icon:'ðŸ‘‘'},
    {id:'combo_anchor', name:'ì½¤ë³´ ë‹»', desc:'ì½¤ë³´ ìœ ì§€ì‹œê°„ +50%', icon:'âš“'},
    {id:'big_pin', name:'ê±°ëŒ€ í•€', desc:'ë“œë ˆì¸ ì„¸ì´ë²„ í¬ê¸° 1.6ë°°', icon:'ðŸ“'},
    {id:'triple_choice', name:'ì„ íƒì˜ ë‚˜ì¹¨ë°˜', desc:'ê°•í™” ë½‘ê¸° ì„ íƒì§€ +1', icon:'ðŸ§­'},
];

const CONSUMABLES = [
    {id:'deep_sea', name:'ì‹¬í•´ ë³´ë„ˆìŠ¤', desc:'10ì´ˆê°„ ì ìˆ˜ 3ë°°', color:[60,180,255], icon:'ðŸŒŠ', weight:20},
    {id:'shield', name:'ë°©ì–´ë§‰', desc:'1íšŒ ë“œë ˆì¸ ë°©ì§€', color:[100,255,200], icon:'ðŸ›¡ï¸', weight:25},
    {id:'slow_time', name:'ìŠ¬ë¡œìš° íƒ€ìž„', desc:'8ì´ˆê°„ ì¤‘ë ¥ 50% ê°ì†Œ', color:[180,140,255], icon:'ðŸŒ', weight:25},
    {id:'combo_master', name:'ì½¤ë³´ ë§ˆìŠ¤í„°', desc:'ì½¤ë³´ ìœ ì§€ì‹œê°„ 2ë°°', color:[255,160,60], icon:'ðŸ”¥', weight:18},
    {id:'temp_life', name:'ìž„ì‹œ ìƒëª…', desc:'ì´ë²ˆ ë¼ìš´ë“œ ìƒëª… +1', color:[255,100,120], icon:'â¤ï¸', weight:12},
];

// ============================================================
//  BALL TYPES (Gacha)
// ============================================================
const RARITY_COLORS = [[180,200,220],[100,180,255],[255,220,50]];
const RARITY_GLOW = [[80,100,120],[60,120,200],[200,180,30]];

const BALL_TYPES = [
    {id:'normal',name:'ê¸°ë³¸ ê³µ',desc:'í‰ë²”í•œ ì§„ì£¼ ê³µ',rarity:0,rarity_name:'ì¼ë°˜',color:PEARL,trail:PEARL2,weight:0,effects:{}},
    {id:'heavy',name:'ë¬´ê±°ìš´ ê³µ',desc:'ë²”í¼ ì ìˆ˜ +25%',rarity:0,rarity_name:'ì¼ë°˜',color:[180,160,140],trail:[150,130,110],weight:25,effects:{bumper_mult:1.25}},
    {id:'feather',name:'ê¹ƒí„¸ ê³µ',desc:'ì¤‘ë ¥ -20%, ê°€ë³ê²Œ ë– ë‹¤ë‹˜',rarity:0,rarity_name:'ì¼ë°˜',color:[220,240,255],trail:[180,210,255],weight:25,effects:{gravity_mult:0.8}},
    {id:'fire',name:'ë¶ˆê½ƒ ê³µ',desc:'ëª¨ë“  ì ìˆ˜ +30%',rarity:1,rarity_name:'í¬ê·€',color:[255,120,60],trail:[255,80,30],weight:12,effects:{score_mult:1.3}},
    {id:'magnet',name:'ìžì„ ê³µ',desc:'ë°°ìˆ˜êµ¬ ê·¼ì²˜ì—ì„œ ì¤‘ì•™ìœ¼ë¡œ ëŒë¦¼',rarity:1,rarity_name:'í¬ê·€',color:[220,80,80],trail:[180,60,60],weight:12,effects:{magnet:true}},
    {id:'combo',name:'ì½¤ë³´ ê³µ',desc:'ì½¤ë³´ ìœ ì§€ ì‹œê°„ +80%',rarity:1,rarity_name:'í¬ê·€',color:[100,255,200],trail:[70,220,170],weight:12,effects:{combo_extend:1.8}},
    {id:'golden',name:'í™©ê¸ˆ ê³µ',desc:'ëª¨ë“  ì ìˆ˜ x1.5, ê³¨ë“œ x2',rarity:2,rarity_name:'ì „ì„¤',color:[255,220,50],trail:[255,200,30],weight:5,effects:{score_mult:1.5,gold_mult:2.0}},
    {id:'split',name:'ë¶„ì—´ ê³µ',desc:'ë²”í¼ ì¶©ëŒ ì‹œ 20% í™•ë¥ ë¡œ ë¶„ì—´',rarity:2,rarity_name:'ì „ì„¤',color:[180,100,255],trail:[150,70,230],weight:5,effects:{split_chance:0.2}},
    {id:'ghost',name:'ìœ ë ¹ ê³µ',desc:'ìŠ¬ë§ìƒ· ë¬´ì‹œ, ì‹ ë¹„ë¡œìš´ ê¶¤ì ',rarity:2,rarity_name:'ì „ì„¤',color:[200,220,255],trail:[160,180,220],weight:4,effects:{ghost:true}},
];

// ============================================================
//  HELPERS
// ============================================================
function rgb(c) { return `rgb(${c[0]},${c[1]},${c[2]})`; }
function rgba(c, a) { return `rgba(${c[0]},${c[1]},${c[2]},${a})`; }
function lerp_col(c1, c2, t) {
    t = Math.max(0, Math.min(1, t));
    return [
        Math.round(c1[0]+(c2[0]-c1[0])*t),
        Math.round(c1[1]+(c2[1]-c1[1])*t),
        Math.round(c1[2]+(c2[2]-c1[2])*t)
    ];
}
function v_dot(a, b) { return a[0]*b[0]+a[1]*b[1]; }
function v_len(v) { return Math.hypot(v[0], v[1]); }
function v_nrm(v) { const l = v_len(v); return l > 0.001 ? [v[0]/l, v[1]/l] : [0, 0]; }
function v_perp(v) { return [-v[1], v[0]]; }

function nearest_on_seg(px, py, ax, ay, bx, by) {
    const dx = bx-ax, dy = by-ay;
    const l2 = dx*dx+dy*dy;
    if (l2 < 0.001) return [ax, ay];
    const t = Math.max(0, Math.min(1, ((px-ax)*dx+(py-ay)*dy)/l2));
    return [ax+t*dx, ay+t*dy];
}

function seg_circ(cx, cy, r, ax, ay, bx, by) {
    const [nx, ny] = nearest_on_seg(cx, cy, ax, ay, bx, by);
    const dx = cx-nx, dy = cy-ny;
    const d = Math.hypot(dx, dy);
    if (0.001 < d && d < r) return { hit:true, n:[dx/d, dy/d], pen:r-d };
    return { hit:false, n:[0,0], pen:0 };
}

function circ_circ(x1, y1, r1, x2, y2, r2) {
    const dx = x1-x2, dy = y1-y2;
    const d = Math.hypot(dx, dy);
    if (0.001 < d && d < r1+r2) return { hit:true, n:[dx/d, dy/d], pen:r1+r2-d };
    return { hit:false, n:[0,0], pen:0 };
}

function randUniform(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(a + Math.random() * (b - a + 1)); }
function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

// ============================================================
//  AUDIO (Web Audio API)
// ============================================================
let audioCtx = null;
const SND = {};

function initAudio() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playTone(freq, dur = 0.08, vol = 0.12) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = 'sine';
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
}

function playSweep(f1, f2, dur = 0.15, vol = 0.10) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.frequency.setValueAtTime(f1, audioCtx.currentTime);
    osc.frequency.linearRampToValueAtTime(f2, audioCtx.currentTime + dur);
    osc.type = 'sine';
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
}

function sndBump() { playTone(800, 0.05, 0.10); }
function sndFlip() { playTone(350, 0.03, 0.06); }
function sndWall() { playTone(500, 0.025, 0.05); }
function sndDrain() { playTone(180, 0.3, 0.12); }
function sndLaunch() { playSweep(200, 900, 0.2, 0.08); }
function sndTarget() { playTone(1000, 0.06, 0.08); }
function sndSpin() { playTone(600, 0.04, 0.06); }
function sndMulti() { playSweep(400, 1200, 0.3, 0.12); }
function sndBonus() { playSweep(300, 1500, 0.5, 0.10); }
function sndBuy() { playTone(1200, 0.08, 0.10); }
function sndRoundClear() { playSweep(500, 1800, 0.6, 0.12); }

// ============================================================
//  CANVAS SETUP
// ============================================================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = WIDTH;
canvas.height = HEIGHT;

function fillCircle(x, y, r, col) {
    ctx.fillStyle = rgb(col);
    ctx.beginPath(); ctx.arc(x, y, Math.max(0.5, r), 0, Math.PI*2); ctx.fill();
}
function strokeCircle(x, y, r, col, lw=1) {
    ctx.strokeStyle = rgb(col); ctx.lineWidth = lw;
    ctx.beginPath(); ctx.arc(x, y, Math.max(0.5, r), 0, Math.PI*2); ctx.stroke();
}
function fillRect(x, y, w, h, col) {
    ctx.fillStyle = rgb(col); ctx.fillRect(x, y, w, h);
}
function drawLine(x1, y1, x2, y2, col, lw=1) {
    ctx.strokeStyle = rgb(col); ctx.lineWidth = lw;
    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
}
function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
}
function fillText(text, x, y, col, font='14px "Malgun Gothic", sans-serif', align='left') {
    ctx.fillStyle = rgb(col); ctx.font = font; ctx.textAlign = align;
    ctx.fillText(text, x, y);
}
function measureText(text, font='14px "Malgun Gothic", sans-serif') {
    ctx.font = font; return ctx.measureText(text).width;
}
function fillRoundRect(x, y, w, h, r, col) {
    ctx.fillStyle = rgb(col);
    ctx.beginPath();
    ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath(); ctx.fill();
}
function strokeRoundRect(x, y, w, h, r, col, lw=2) {
    ctx.strokeStyle = rgb(col); ctx.lineWidth = lw;
    ctx.beginPath();
    ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath(); ctx.stroke();
}
function hslToRgb(h, s, l) {
    h /= 360; s /= 100; l /= 100;
    let r, g, b;
    if (s === 0) { r = g = b = l; } else {
        const hue2rgb = (p, q, t) => { if(t<0)t+=1; if(t>1)t-=1; if(t<1/6)return p+(q-p)*6*t; if(t<1/2)return q; if(t<2/3)return p+(q-p)*(2/3-t)*6; return p; };
        const q = l < 0.5 ? l*(1+s) : l+s-l*s;
        const p = 2*l-q;
        r = hue2rgb(p, q, h+1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h-1/3);
    }
    return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
}

// ============================================================
//  PARTICLE / BUBBLE / SCOREPOPUP
// ============================================================
class Particle {
    constructor(x, y, vx, vy, color, life, size=3, grav=0) {
        this.x=x; this.y=y; this.vx=vx; this.vy=vy;
        this.color=color; this.life=life; this.mx=life;
        this.size=size; this.grav=grav;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.vy += this.grav;
        this.life--; return this.life > 0;
    }
    draw() {
        const a = this.life / this.mx;
        const r = Math.max(1, Math.round(this.size * a));
        const c = lerp_col(BLACK, this.color, a);
        fillCircle(this.x, this.y, r, c);
    }
}

class Bubble {
    constructor() {
        this.x = randUniform(TABLE_L, TABLE_R);
        this.y = randUniform(50, HEIGHT);
        this.r = randUniform(2, 6);
        this.spd = randUniform(0.3, 1.0);
        this.wa = randUniform(0.5, 2);
        this.ws = randUniform(0.02, 0.06);
        this.ph = randUniform(0, Math.PI*2);
    }
    update(t) {
        this.y -= this.spd;
        this.x += Math.sin(t * this.ws + this.ph) * this.wa * 0.3;
        if (this.y < -10) {
            this.x = randUniform(TABLE_L, TABLE_R);
            this.y = HEIGHT + randUniform(0, 50);
            this.r = randUniform(2, 6);
        }
    }
    draw() {
        const c = [Math.min(255, 180+Math.round(this.r*10)), Math.min(255, 220+Math.round(this.r*5)), 255];
        strokeCircle(this.x, this.y, this.r, c, 1);
        if (this.r > 3) fillCircle(this.x - this.r*0.3, this.y - this.r*0.3, Math.max(1, this.r*0.3), WHITE);
    }
}

class ScorePopup {
    constructor(x, y, text, color=SCORE_C) {
        this.x=x; this.y=y; this.text=text; this.color=color; this.life=60;
    }
    update() { this.y -= 1.2; this.life--; return this.life > 0; }
    draw() {
        const a = this.life / 60.0;
        const c = lerp_col([50,50,50], this.color, a);
        fillText(this.text, this.x, this.y, c, '14px "Malgun Gothic", sans-serif', 'center');
    }
}

// ============================================================
//  BALL
// ============================================================
class Ball {
    constructor(x, y, vx=0, vy=0, ballType=null) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.active = true; this.trail = [];
        this.in_lane = (x > TABLE_R);
        this.ball_type = ballType;
    }
    step(tilt_x=0, dt=0.5, gravity=GRAVITY) {
        this.vy += gravity * dt;
        this.vx += tilt_x * dt;
        let spd = Math.hypot(this.vx, this.vy);
        if (spd > MAX_SPEED) { const f = MAX_SPEED/spd; this.vx*=f; this.vy*=f; }
        this.vx *= (1 - 0.001*dt);
        this.vy *= (1 - 0.001*dt);
        this.x += this.vx * dt;
        this.y += this.vy * dt;
    }
    collide_walls(walls) {
        let hitAny = false;
        for (const [[ax,ay],[bx,by]] of walls) {
            const {hit, n, pen} = seg_circ(this.x, this.y, BALL_R, ax, ay, bx, by);
            if (hit) {
                this.x += n[0]*pen; this.y += n[1]*pen;
                const vn = v_dot([this.vx,this.vy], n);
                if (vn < 0) {
                    this.vx -= 2*vn*n[0]*0.7;
                    this.vy -= 2*vn*n[1]*0.7;
                    hitAny = true;
                }
            }
        }
        return hitAny;
    }
    update_trail() {
        this.trail.push([this.x, this.y]);
        const bid = this.ball_type ? this.ball_type.id : 'normal';
        const maxTrail = ['fire','feather','magnet','combo','ghost'].includes(bid) ? 14 : 8;
        while (this.trail.length > maxTrail) this.trail.shift();
    }
    draw(t) {
        const bt = this.ball_type;
        const main_c = bt ? bt.color : PEARL;
        const trail_c = bt ? bt.trail : PEARL2;
        const outline_c = bt ? lerp_col(main_c, BLACK, 0.3) : PEARL2;
        const bid = bt ? bt.id : 'normal';
        const trail_len = this.trail.length;

        // --- Trail ---
        for (let i = 0; i < trail_len; i++) {
            const [tx, ty] = this.trail[i];
            const a = (i+1) / Math.max(trail_len, 1);
            if (bid === 'feather') {
                const wave = Math.sin(t*0.15+i*0.8)*4;
                const r = Math.max(1, Math.round(BALL_R*a*0.6));
                fillCircle(tx+wave, ty, r, lerp_col([180,220,255], trail_c, a));
                if (i%2===0) fillCircle(tx+wave*1.5, ty-2, Math.max(1,Math.floor(r/2)), [240,250,255]);
            } else if (bid === 'heavy') {
                const r = Math.max(2, Math.round(BALL_R*a*0.7));
                fillCircle(tx, ty, r, lerp_col([100,90,70], trail_c, a));
            } else if (bid === 'magnet') {
                const r = Math.max(1, Math.round(BALL_R*a*0.5));
                const jx = a>0.3 ? randUniform(-2,2) : 0;
                const jy = a>0.3 ? randUniform(-2,2) : 0;
                fillCircle(tx+jx, ty+jy, r, lerp_col([100,30,30], trail_c, a));
                if (i>0 && a>0.4) {
                    const [px, py] = this.trail[i-1];
                    drawLine(px+jx, py+jy, tx+jx, ty+jy, [255,120,120], 1);
                }
            } else if (bid === 'combo') {
                const hue = (t*2+i*30)%360;
                const rc = hslToRgb(hue, 80, 60);
                const r = Math.max(1, Math.round(BALL_R*a*0.5));
                fillCircle(tx, ty, r, rc);
            } else if (bid === 'split') {
                const r = Math.max(1, Math.round(BALL_R*a*0.4));
                const c = lerp_col([80,40,120], trail_c, a);
                fillCircle(tx-2, ty, r, c); fillCircle(tx+2, ty, r, c);
            } else if (bid === 'fire') {
                const r = Math.max(2, Math.round(BALL_R*a*0.7));
                const flicker = randUniform(-2,2);
                fillCircle(tx+flicker, ty+flicker, r, lerp_col([200,50,0],[255,200,50], a));
            } else {
                const r = Math.max(1, Math.round(BALL_R*a*0.4));
                fillCircle(tx, ty, r, lerp_col(MID_SEA, trail_c, a));
            }
        }

        // --- Pre-ball glow effects ---
        if (bid === 'ghost') {
            const alpha = (50 + 30*Math.sin(t*0.12)) / 255;
            ctx.fillStyle = rgba(main_c, alpha);
            ctx.beginPath(); ctx.arc(this.x, this.y, BALL_R*4, 0, Math.PI*2); ctx.fill();
        }
        if (bid === 'feather') {
            for (let k=0;k<3;k++) {
                const fa = t*0.06+k*2.1;
                const fx = this.x + Math.sin(fa)*12;
                const fy = this.y - 8 - (t*0.3+k*5)%20;
                fillCircle(fx, fy, 2, [200,230,255]);
            }
        }
        if (bid === 'magnet') {
            for (let k=0;k<4;k++) {
                const ang = t*0.1+k*Math.PI/2;
                const ex = this.x + (BALL_R+6)*Math.cos(ang);
                const ey = this.y + (BALL_R+6)*Math.sin(ang);
                const pulse = Math.sin(t*0.2+k)*3;
                drawLine(
                    this.x + BALL_R*0.7*Math.cos(ang), this.y + BALL_R*0.7*Math.sin(ang),
                    ex+pulse, ey+pulse, [255,100,100], 2);
            }
        }
        if (bid === 'heavy') {
            const spd = Math.hypot(this.vx, this.vy);
            if (spd > 3) strokeCircle(this.x, this.y, BALL_R+3+spd*0.3, [120,100,70], 2);
        }
        if (bid === 'combo') {
            for (let k=0;k<8;k++) {
                const ang = t*0.1+k*Math.PI/4;
                const hue = (t*3+k*45)%360;
                const rc = hslToRgb(hue, 90, 60);
                fillCircle(this.x+(BALL_R+3)*Math.cos(ang), this.y+(BALL_R+3)*Math.sin(ang), 2, rc);
            }
        }
        if (bid === 'split') {
            for (let k=0;k<2;k++) {
                const ang = t*0.12+k*Math.PI;
                const ox = this.x+(BALL_R+5)*Math.cos(ang);
                const oy = this.y+(BALL_R+5)*Math.sin(ang);
                fillCircle(ox, oy, 3, [150,80,230]);
                fillCircle(ox, oy, 2, [200,160,255]);
            }
        }
        if (bid === 'fire') {
            for (let k=0;k<5;k++) {
                const fa = randUniform(0, Math.PI*2);
                const fd = BALL_R + randUniform(2,8);
                const fx = this.x + fd*Math.cos(fa);
                const fy = this.y + fd*Math.sin(fa) - randUniform(0,4);
                fillCircle(fx, fy, randInt(1,3), randChoice([[255,200,50],[255,120,30],[255,80,10]]));
            }
        }
        if (bid === 'golden') {
            ctx.fillStyle = rgba([255,220,50], 0.14);
            ctx.beginPath(); ctx.arc(this.x, this.y, BALL_R*3, 0, Math.PI*2); ctx.fill();
            for (let k=0;k<8;k++) {
                const ang = t*0.06+k*Math.PI/4;
                const dist = BALL_R+5+Math.sin(t*0.15+k)*3;
                const sz = 2+Math.sin(t*0.2+k*0.8);
                fillCircle(this.x+dist*Math.cos(ang), this.y+dist*Math.sin(ang), Math.max(1,sz), GOLD_C);
            }
        }

        // --- Main ball ---
        fillCircle(this.x, this.y, BALL_R, main_c);
        fillCircle(this.x-2, this.y-2, Math.max(1, Math.floor(BALL_R/3)), WHITE);
        strokeCircle(this.x, this.y, BALL_R, outline_c, 1);
    }
}

// ============================================================
//  FLIPPER
// ============================================================
class Flipper {
    constructor(px, py, side, length=FLIP_LEN) {
        this.px=px; this.py=py; this.side=side; this.length=length;
        if (side==='left') { this.rest=0.45; this.act=-0.45; }
        else { this.rest=Math.PI-0.45; this.act=Math.PI+0.45; }
        this.angle=this.rest; this.prev_angle=this.rest; this.ang_v=0; this.on=false;
    }
    tip() {
        return [this.px+this.length*Math.cos(this.angle), this.py+this.length*Math.sin(this.angle)];
    }
    update() {
        this.prev_angle = this.angle;
        const tgt = this.on ? this.act : this.rest;
        const old = this.angle;
        const spd = this.on ? 0.18 : 0.10;
        const d = tgt - this.angle;
        if (Math.abs(d) < spd) this.angle = tgt;
        else this.angle += d > 0 ? spd : -spd;
        this.ang_v = this.angle - old;
    }
    collide_ball(ball, power_mult=1.0) {
        const [tx, ty] = this.tip();
        const {hit, n, pen} = seg_circ(ball.x, ball.y, BALL_R+FLIP_W/2, this.px, this.py, tx, ty);
        if (hit) {
            ball.x += n[0]*pen; ball.y += n[1]*pen;
            const [cx, cy] = nearest_on_seg(ball.x, ball.y, this.px, this.py, tx, ty);
            const dist = Math.hypot(cx-this.px, cy-this.py);
            const fdir = v_nrm([tx-this.px, ty-this.py]);
            const perp = v_perp(fdir);
            const sv = [perp[0]*this.ang_v*dist, perp[1]*this.ang_v*dist];
            let rvx = ball.vx - sv[0], rvy = ball.vy - sv[1];
            const vn = v_dot([rvx, rvy], n);
            if (vn < 0) {
                ball.vx = rvx - 2*vn*n[0]*0.75*power_mult + sv[0];
                ball.vy = rvy - 2*vn*n[1]*0.75*power_mult + sv[1];
                const kick = Math.abs(this.ang_v)*dist*0.5*power_mult;
                ball.vx += n[0]*kick; ball.vy += n[1]*kick;
                return true;
            }
        }
        return false;
    }
    draw() {
        const [tx, ty] = this.tip();
        const dx = tx-this.px, dy = ty-this.py;
        const length = Math.hypot(dx, dy);
        if (length < 1) return;
        const ux = dx/length, uy = dy/length;
        const px = -uy, py = ux;
        const hw = FLIP_W/2+2;

        // Build flipper shape
        const pts1 = [], pts2 = [];
        for (let i=0; i<8; i++) {
            const t = i/7;
            const mx = this.px+dx*t, my = this.py+dy*t;
            const w = hw*Math.sin(t*Math.PI)*1.3+2;
            pts1.push([mx+px*w, my+py*w]);
        }
        for (let i=7; i>=0; i--) {
            const t = i/7;
            const mx = this.px+dx*t, my = this.py+dy*t;
            const w = hw*Math.sin(t*Math.PI)*1.3+2;
            pts2.push([mx-px*w, my-py*w]);
        }
        const allPts = [...pts1, ...pts2];

        ctx.fillStyle = rgb(SHELL_C);
        ctx.beginPath(); ctx.moveTo(allPts[0][0], allPts[0][1]);
        for (let i=1; i<allPts.length; i++) ctx.lineTo(allPts[i][0], allPts[i][1]);
        ctx.closePath(); ctx.fill();

        ctx.strokeStyle = rgb(SHELL_P); ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(allPts[0][0], allPts[0][1]);
        for (let i=1; i<allPts.length; i++) ctx.lineTo(allPts[i][0], allPts[i][1]);
        ctx.closePath(); ctx.stroke();

        // Lines
        for (let i=1; i<6; i++) {
            const t = i/6;
            const sx = this.px+dx*t, sy = this.py+dy*t;
            const w = hw*Math.sin(t*Math.PI);
            drawLine(sx-px*w, sy-py*w, sx+px*w, sy+py*w, SHELL_P, 1);
        }

        fillCircle(this.px, this.py, 5, CORAL_D);
        fillCircle(this.px, this.py, 3, CORAL_C);
    }
}

// ============================================================
//  BUMPER
// ============================================================
// ============================================================
//  PIN (small dot bumper)
// ============================================================
class Pin {
    constructor(x, y, r=5, pts=50) {
        this.x=x; this.y=y; this.r=r; this.pts=pts; this.hit_t=0;
    }
    update() { if (this.hit_t > 0) this.hit_t--; }
    collide_ball(ball) {
        const {hit, n, pen} = circ_circ(ball.x, ball.y, BALL_R, this.x, this.y, this.r);
        if (hit) {
            ball.x += n[0]*pen; ball.y += n[1]*pen;
            const spd = Math.max(3, Math.hypot(ball.vx, ball.vy));
            ball.vx = n[0]*spd*0.9; ball.vy = n[1]*spd*0.9;
            this.hit_t = 10; return true;
        }
        return false;
    }
    draw(t) {
        const c = this.hit_t > 0 ? WHITE : [180, 200, 220];
        fillCircle(this.x, this.y, this.r, c);
        strokeCircle(this.x, this.y, this.r, [120,140,160], 1);
        if (this.hit_t > 5) strokeCircle(this.x, this.y, this.r+4, [220,230,255], 1);
    }
}

class Bumper {
    constructor(x, y, r, style='puffer', pts=100) {
        this.x=x; this.y=y; this.r=r; this.style=style; this.pts=pts;
        this.hit_t=0; this.pulse=0;
    }
    update() { if (this.hit_t > 0) this.hit_t--; this.pulse += 0.05; }
    collide_ball(ball) {
        const {hit, n, pen} = circ_circ(ball.x, ball.y, BALL_R, this.x, this.y, this.r);
        if (hit) {
            ball.x += n[0]*pen; ball.y += n[1]*pen;
            const spd = Math.max(4, Math.hypot(ball.vx, ball.vy));
            ball.vx = n[0]*spd*1.1; ball.vy = n[1]*spd*1.1;
            this.hit_t = 15; return true;
        }
        return false;
    }
    draw(t) {
        const hr = this.r + (this.hit_t > 0 ? 3 : 0);
        const p = Math.sin(this.pulse)*2;
        if (this.style === 'puffer') {
            const bc = this.hit_t > 8 ? WHITE : PUFFER_Y;
            for (let i=0;i<12;i++) {
                const ang = i*Math.PI*2/12+t*0.05;
                fillCircle(this.x+(hr+p+2)*Math.cos(ang), this.y+(hr+p+2)*Math.sin(ang), 3, PUFFER_D);
            }
            fillCircle(this.x, this.y, hr+p, bc);
            // Eyes
            const ex_off = hr*0.35, ey = this.y - hr*0.1;
            fillCircle(this.x-ex_off, ey, 7, WHITE);
            fillCircle(this.x+ex_off, ey, 7, WHITE);
            fillCircle(this.x-ex_off, ey, 3, BLACK);
            fillCircle(this.x+ex_off, ey, 3, BLACK);
            fillCircle(this.x-ex_off-1, ey-1, 1, WHITE);
            fillCircle(this.x+ex_off-1, ey-1, 1, WHITE);
            // Cheeks
            fillCircle(this.x-ex_off-2, ey+5, 3, [255,180,180]);
            fillCircle(this.x+ex_off+2, ey+5, 3, [255,180,180]);
            if (this.hit_t > 10) strokeCircle(this.x, this.y, hr+10, [255,255,200], 2);
        } else {
            const bc = this.hit_t > 0 ? [240,220,255] : JELLY_P;
            // Ellipse approximation
            ctx.fillStyle = rgb(bc);
            ctx.beginPath(); ctx.ellipse(this.x, this.y, hr+p, hr*0.6, 0, 0, Math.PI*2); ctx.fill();
            fillCircle(this.x-6, this.y-5, 2, BLACK);
            fillCircle(this.x+6, this.y-5, 2, BLACK);
            fillCircle(this.x-10, this.y+2, 3, [255,150,150]);
            fillCircle(this.x+10, this.y+2, 3, [255,150,150]);
            if (this.hit_t > 0) {
                const gr = hr+8+this.hit_t;
                ctx.fillStyle = rgba(JELLY_B, 0.2);
                ctx.beginPath(); ctx.arc(this.x, this.y, gr, 0, Math.PI*2); ctx.fill();
            }
            // Tentacles
            for (let i=0;i<5;i++) {
                const tx2 = this.x - hr*0.5+i*(hr*0.25);
                const ty2 = this.y + hr*0.4;
                const off = Math.sin(t*0.1+i)*5;
                drawLine(tx2, ty2, tx2+off, ty2+10, JELLY_K, 3);
                fillCircle(tx2+off, ty2+10, 2, JELLY_K);
            }
        }
    }
}

// ============================================================
//  BOSS (trash theme, appears every 3rd round)
// ============================================================
const BOSS_GOLD_REWARD = 3;
class Boss {
    constructor(x, y, ante) {
        this.x = x; this.y = y;
        this.r = 30 + ante * 3; // grows with ante
        this.max_hp = 3 + ante; // ante1=4, ante2=5, ante3=6...
        this.hp = this.max_hp;
        this.alive = true;
        this.hit_t = 0;
        this.wobble = 0;
        this.death_t = 0; // death animation timer
        this.ante = ante;
        this.base_y = y;

        // Movement (ante 2+)
        this.moves = ante >= 2;
        this.move_t = 0;
        this.move_speed = 0.008 + ante * 0.003; // faster at higher ante
        this.move_range_x = 60 + ante * 10; // wider at higher ante
        this.move_range_y = 20 + ante * 5;

        this.heal_flash = 0;

        // Boss debuff abilities (ante 3+)
        this.debuff = null; // current active debuff
        this.debuff_timer = 0;
        this.debuff_cooldown = 0;
        this._pick_debuffs(ante);
    }
    _pick_debuffs(ante) {
        // Ante 3+: boss has debuff abilities
        this.debuff_pool = [];
        if (ante >= 3) this.debuff_pool.push('gravity_up');   // increase gravity
        if (ante >= 4) this.debuff_pool.push('flip_reverse'); // reverse flippers
        if (ante >= 5) this.debuff_pool.push('heal');           // boss heals 1 HP
        if (ante >= 6) this.debuff_pool.push('flip_lock_left', 'flip_lock_right'); // lock one flipper
    }
    update() {
        if (this.hit_t > 0) this.hit_t--;
        if (this.heal_flash > 0) this.heal_flash--;
        this.wobble += 0.04;
        if (!this.alive && this.death_t > 0) this.death_t--;

        // Movement
        if (this.alive && this.moves) {
            this.move_t += this.move_speed;
            this.x = WIDTH / 2 + Math.sin(this.move_t) * this.move_range_x;
            this.y = this.base_y + Math.sin(this.move_t * 0.7) * this.move_range_y;
        }

        // Debuff logic
        if (this.alive && this.debuff_pool.length > 0) {
            if (this.debuff_timer > 0) {
                this.debuff_timer--;
                if (this.debuff_timer <= 0) this.debuff = null;
            } else if (this.debuff_cooldown > 0) {
                this.debuff_cooldown--;
            } else {
                // Activate random debuff
                this.debuff = this.debuff_pool[Math.floor(Math.random() * this.debuff_pool.length)];
                if (this.debuff === 'heal') {
                    // Instant heal, no duration
                    if (this.hp < this.max_hp) {
                        this.hp++;
                        this.heal_flash = 30; // signal for visual effect
                    }
                    this.debuff = null;
                    this.debuff_cooldown = 300;
                } else {
                    this.debuff_timer = 180; // ~3 seconds
                    this.debuff_cooldown = 300; // ~5 seconds between debuffs
                }
            }
        }
        if (!this.alive) this.debuff = null;
    }
    collide_ball(ball) {
        if (!this.alive) return false;
        const {hit, n, pen} = circ_circ(ball.x, ball.y, BALL_R, this.x, this.y, this.r);
        if (hit) {
            ball.x += n[0]*pen; ball.y += n[1]*pen;
            const spd = Math.max(4, Math.hypot(ball.vx, ball.vy));
            ball.vx = n[0]*spd*0.9; ball.vy = n[1]*spd*0.9;
            this.hp--;
            this.hit_t = 12;
            if (this.hp <= 0) {
                this.alive = false;
                this.death_t = 60;
            }
            return true;
        }
        return false;
    }
    draw(t) {
        if (!this.alive) {
            // Death explosion animation
            if (this.death_t > 0) {
                const prog = this.death_t / 60;
                const er = this.r * (2 - prog);
                ctx.globalAlpha = prog * 0.6;
                fillCircle(this.x, this.y, er, [120, 100, 80]);
                // Debris
                for (let i = 0; i < 8; i++) {
                    const a = i * Math.PI * 2 / 8 + t * 0.05;
                    const dr = er * (1.2 + (1 - prog) * 0.8);
                    const dx = this.x + Math.cos(a) * dr;
                    const dy = this.y + Math.sin(a) * dr;
                    fillCircle(dx, dy, 3 + prog * 4, [90, 80, 60]);
                }
                ctx.globalAlpha = 1;
            }
            return;
        }
        const hr = this.r + (this.hit_t > 0 ? 4 : 0);
        const wx = Math.sin(this.wobble) * 2;
        const wy = Math.cos(this.wobble * 0.7) * 1.5;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(this.x, this.y + hr * 0.7, hr * 0.9, hr * 0.3, 0, 0, Math.PI * 2); ctx.fill();

        // Trash bag body (dark greenish brown)
        const bodyCol = this.hit_t > 6 ? [220, 200, 180] : [70, 80, 50];
        ctx.fillStyle = rgb(bodyCol);
        ctx.beginPath();
        ctx.ellipse(this.x + wx, this.y + wy, hr * 0.9, hr, 0, 0, Math.PI * 2);
        ctx.fill();

        // Bag texture lines
        ctx.strokeStyle = this.hit_t > 6 ? 'rgba(180,160,140,0.6)' : 'rgba(40,50,30,0.6)';
        ctx.lineWidth = 1.5;
        for (let i = -2; i <= 2; i++) {
            const lx = this.x + wx + i * hr * 0.3;
            drawLine(lx, this.y + wy - hr * 0.6, lx + i * 2, this.y + wy + hr * 0.6,
                this.hit_t > 6 ? [180,160,140] : [50,60,35], 1);
        }

        // Bag tie at top
        ctx.fillStyle = this.hit_t > 6 ? rgb([200,180,160]) : rgb([90, 100, 60]);
        ctx.beginPath();
        ctx.ellipse(this.x + wx, this.y + wy - hr * 0.85, hr * 0.35, hr * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        // Trash sticking out
        const stickCol = [180, 150, 100];
        // Banana peel
        ctx.fillStyle = rgb([220, 200, 60]);
        ctx.beginPath();
        ctx.moveTo(this.x + wx - hr * 0.3, this.y + wy - hr * 0.7);
        ctx.quadraticCurveTo(this.x + wx - hr * 0.5, this.y + wy - hr * 1.1,
            this.x + wx - hr * 0.15, this.y + wy - hr * 1.0);
        ctx.lineWidth = 2; ctx.stroke(); ctx.fill();

        // Can sticking out
        fillCircle(this.x + wx + hr * 0.25, this.y + wy - hr * 0.75, 5, [150, 160, 170]);
        strokeCircle(this.x + wx + hr * 0.25, this.y + wy - hr * 0.75, 5, [100, 110, 120], 1);

        // Fish bone
        const fbx = this.x + wx + hr * 0.1, fby = this.y + wy - hr * 0.5;
        drawLine(fbx - 6, fby, fbx + 6, fby, [200, 200, 190], 1.5);
        for (let i = -2; i <= 2; i++) {
            const fx = fbx + i * 3;
            drawLine(fx, fby - 3, fx, fby + 3, [200, 200, 190], 1);
        }

        // Angry eyes
        const ex_off = hr * 0.25;
        const ey = this.y + wy - hr * 0.15;
        // Eye whites
        fillCircle(this.x + wx - ex_off, ey, 6, [200, 200, 180]);
        fillCircle(this.x + wx + ex_off, ey, 6, [200, 200, 180]);
        // Pupils
        fillCircle(this.x + wx - ex_off, ey + 1, 3, [40, 30, 20]);
        fillCircle(this.x + wx + ex_off, ey + 1, 3, [40, 30, 20]);
        // Angry eyebrows
        drawLine(this.x + wx - ex_off - 5, ey - 7, this.x + wx - ex_off + 4, ey - 4, [60, 50, 30], 2);
        drawLine(this.x + wx + ex_off + 5, ey - 7, this.x + wx + ex_off - 4, ey - 4, [60, 50, 30], 2);

        // Hit flash ring
        if (this.hit_t > 8) {
            strokeCircle(this.x + wx, this.y + wy, hr + 8, [255, 200, 100], 3);
        }

        // HP bar above boss
        const barW = hr * 2, barH = 6;
        const barX = this.x - barW / 2, barY = this.y - hr - 18;
        fillRect(barX, barY, barW, barH, [30, 30, 30]);
        const hpRatio = this.hp / this.max_hp;
        const hpCol = hpRatio > 0.5 ? [80, 200, 80] : (hpRatio > 0.25 ? [220, 180, 40] : [220, 60, 40]);
        fillRect(barX, barY, Math.round(barW * hpRatio), barH, hpCol);
        ctx.strokeStyle = rgb([80, 80, 80]); ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);
        fillText(`${this.hp}/${this.max_hp}`, this.x, barY - 3, WHITE, '10px "Malgun Gothic", sans-serif', 'center');

        // Heal flash effect
        if (this.heal_flash > 0) {
            const hp = this.heal_flash / 30;
            // Green glow ring expanding outward
            const ringR = hr + (1 - hp) * 40;
            ctx.globalAlpha = hp * 0.7;
            strokeCircle(this.x + wx, this.y + wy, ringR, [80, 255, 120], 3);
            ctx.globalAlpha = hp * 0.3;
            fillCircle(this.x + wx, this.y + wy, hr + 5, [80, 255, 120]);
            ctx.globalAlpha = 1;
            // Rising + particles
            if (this.heal_flash % 4 === 0) {
                const px = this.x + wx + (Math.random() - 0.5) * hr * 1.5;
                const py = this.y + wy + (Math.random() - 0.5) * hr;
                fillText('ðŸ’š', px, py - (30 - this.heal_flash), WHITE, '14px sans-serif', 'center');
            }
            // "+1 HP" text
            const txtAlpha = Math.min(1, hp * 2);
            ctx.globalAlpha = txtAlpha;
            fillText('+1 HP', this.x, this.y - hr - 30 - (1 - hp) * 15, [80, 255, 120], 'bold 14px "Malgun Gothic", sans-serif', 'center');
            ctx.globalAlpha = 1;
        }

        // Debuff casting aura
        if (this.debuff) {
            const auraR = hr + 15 + Math.sin(t * 0.15) * 5;
            ctx.globalAlpha = 0.2 + Math.sin(t * 0.1) * 0.1;
            const auraCols = {
                'flip_lock_left': [200, 50, 50],
                'flip_lock_right': [200, 50, 50],
                'flip_reverse': [200, 150, 50],
                'heal': [50, 200, 50],
                'gravity_up': [50, 50, 200]
            };
            const ac = auraCols[this.debuff] || [150,150,150];
            fillCircle(this.x + wx, this.y + wy, auraR, ac);
            ctx.globalAlpha = 1;
        }
    }
}

// ============================================================
//  SLINGSHOT
// ============================================================
class Slingshot {
    constructor(x1, y1, x2, y2, pts=10) {
        this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; this.pts=pts; this.hit_t=0;
    }
    update() { if (this.hit_t > 0) this.hit_t--; }
    collide_ball(ball) {
        const {hit, n, pen} = seg_circ(ball.x, ball.y, BALL_R+3, this.x1, this.y1, this.x2, this.y2);
        if (hit) {
            ball.x += n[0]*pen; ball.y += n[1]*pen;
            const vn = v_dot([ball.vx, ball.vy], n);
            if (vn < 0) {
                ball.vx -= 2.2*vn*n[0]; ball.vy -= 2.2*vn*n[1];
                ball.vy -= 3; this.hit_t = 10; return true;
            }
        }
        return false;
    }
    draw(t) {
        const c = this.hit_t > 0 ? WHITE : CORAL_C;
        const dx = this.x2-this.x1, dy = this.y2-this.y1;
        const l = Math.hypot(dx, dy);
        if (l < 1) return;
        const ux = dx/l, uy = dy/l;
        const px = -uy, py = ux;
        const w = 6;
        const pts = [
            [this.x1+px*w, this.y1+py*w], [this.x2+px*w, this.y2+py*w],
            [this.x2-px*w, this.y2-py*w], [this.x1-px*w, this.y1-py*w]
        ];
        ctx.fillStyle = rgb(c);
        ctx.beginPath(); ctx.moveTo(pts[0][0], pts[0][1]);
        for (let i=1;i<4;i++) ctx.lineTo(pts[i][0], pts[i][1]);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = rgb(CORAL_D); ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(pts[0][0], pts[0][1]);
        for (let i=1;i<4;i++) ctx.lineTo(pts[i][0], pts[i][1]);
        ctx.closePath(); ctx.stroke();
        for (let i=0;i<3;i++) {
            const tp = (i+1)/4;
            const bx = this.x1+dx*tp+px*w;
            const by = this.y1+dy*tp+py*w;
            fillCircle(bx, by, 4, CORAL_D);
            fillCircle(bx, by, 3, c);
        }
    }
}

// ============================================================
//  DROP TARGET (Fish)
// ============================================================
class DropTarget {
    constructor(x, y, color, pts=200) {
        this.x=x; this.y=y; this.color=color; this.pts=pts; this.alive=true; this.anim=0;
    }
    update() { if (this.anim > 0) this.anim--; }
    collide_ball(ball) {
        if (!this.alive) return false;
        const {hit, n, pen} = circ_circ(ball.x, ball.y, BALL_R, this.x, this.y, 12);
        if (hit) {
            ball.x += n[0]*pen; ball.y += n[1]*pen;
            const vn = v_dot([ball.vx,ball.vy], n);
            if (vn < 0) { ball.vx -= 1.5*vn*n[0]; ball.vy -= 1.5*vn*n[1]; }
            this.alive = false; this.anim = 20; return true;
        }
        return false;
    }
    draw(t) {
        if (!this.alive && this.anim <= 0) return;
        if (this.anim > 0 && !this.alive) {
            const a = this.anim / 20;
            const r = Math.round(12*(1+(1-a)*2));
            strokeCircle(this.x, this.y, r, lerp_col([50,50,80], this.color, a), 2);
            return;
        }
        const offset_y = Math.sin(t*0.05+this.x*0.1)*3;
        const cx = this.x, cy = this.y + offset_y;
        // Fish body
        ctx.fillStyle = rgb(this.color);
        // Tail
        const tail_ang = Math.sin(t*0.2+this.x)*0.5;
        const ttx = cx - 14*Math.cos(tail_ang), tty = cy - 14*Math.sin(tail_ang);
        ctx.beginPath();
        ctx.moveTo(cx-8, cy); ctx.lineTo(ttx-6, tty-6); ctx.lineTo(ttx-6, tty+6);
        ctx.closePath(); ctx.fill();
        // Body
        ctx.beginPath(); ctx.ellipse(cx, cy, 12, 10, 0, 0, Math.PI*2); ctx.fill();
        // Eye
        fillCircle(cx+4, cy-3, 5, WHITE);
        fillCircle(cx+6, cy-3, 2, BLACK);
        fillCircle(cx+5, cy-4, 1, WHITE);
    }
}

// ============================================================
//  SPINNER (Whirlpool)
// ============================================================
class Spinner {
    constructor(x, y, pts=50) {
        this.x=x; this.y=y; this.pts=pts; this.angle=0; this.spin=0; this.r=20;
    }
    update() { this.angle += this.spin; this.spin *= 0.97; }
    collide_ball(ball) {
        const {hit, n, pen} = circ_circ(ball.x, ball.y, BALL_R, this.x, this.y, this.r);
        if (hit) {
            ball.x += n[0]*pen; ball.y += n[1]*pen;
            const cross = ball.vx*n[1] - ball.vy*n[0];
            this.spin += cross*0.05;
            const vn = v_dot([ball.vx,ball.vy], n);
            if (vn < 0) { ball.vx -= 1.5*vn*n[0]; ball.vy -= 1.5*vn*n[1]; }
            return true;
        }
        return false;
    }
    draw(t) {
        const cc = Math.abs(this.spin) > 0.5 ? GLOW_C : LIGHT_SEA;
        for (let arm=0; arm<3; arm++) {
            ctx.strokeStyle = rgb(cc); ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i=0; i<20; i++) {
                const a = this.angle + arm*Math.PI*2/3 + i*0.3;
                const r = 3 + i*0.9;
                const px = this.x + r*Math.cos(a), py = this.y + r*Math.sin(a);
                if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.stroke();
        }
        fillCircle(this.x, this.y, 4, cc);
        strokeCircle(this.x, this.y, this.r, MID_SEA, 1);
    }
}

// ============================================================
//  PLUNGER
// ============================================================
class Plunger {
    constructor() {
        this.x = (LANE_IN+LANE_OUT)/2; this.y_base = 750; this.y = this.y_base;
        this.power = 0; this.charging = false; this.max_pw = 100;
    }
    update() {
        if (this.charging) {
            this.power = Math.min(this.power+2, this.max_pw);
            this.y = this.y_base + this.power*0.15;
        } else { this.power = 0; this.y = this.y_base; }
    }
    launch_speed() { return -(this.power*0.12 + 20); }
    draw() {
        const top = this.y - 20;
        fillRect(this.x-4, top, 8, this.y-top+20, [100,100,120]);
        fillCircle(this.x, this.y-3, 5, [120,120,140]);
        if (this.charging && this.power > 0) {
            const bh = Math.round(this.power*0.6);
            const by = this.y_base - 70;
            fillRect(this.x+12, by, 8, 60, [40,40,60]);
            const c = lerp_col([80,200,80],[255,80,80], this.power/this.max_pw);
            fillRect(this.x+12, by+60-bh, 8, bh, c);
        }
    }
}

// ============================================================
//  BONUS STAGE
// ============================================================
class BonusStage {
    constructor() {
        this.active=false; this.timer=0; this.max_t=900;
        this.treasures=[]; this.collected=0; this.total=8; this.particles=[];
    }
    start() {
        this.active=true; this.timer=this.max_t; this.collected=0;
        this.treasures=[];
        for (let i=0;i<this.total;i++) {
            this.treasures.push({x:randUniform(80,400),y:randUniform(150,600),r:12,alive:true,glow:randUniform(0,6.28)});
        }
    }
    update(balls) {
        if (!this.active) return 0;
        this.timer--; let pts=0;
        for (const tr of this.treasures) {
            if (!tr.alive) continue; tr.glow += 0.08;
            for (const ball of balls) {
                if (Math.hypot(ball.x-tr.x, ball.y-tr.y) < BALL_R+tr.r) {
                    tr.alive=false; this.collected++; pts+=5000;
                    for (let k=0;k<10;k++) {
                        this.particles.push(new Particle(tr.x,tr.y,randUniform(-3,3),randUniform(-3,3),TREASURE_C,30,4));
                    }
                }
            }
        }
        this.particles = this.particles.filter(p => p.update());
        if (this.timer <= 0) this.active = false;
        return pts;
    }
    draw() {
        if (!this.active) return;
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        for (const tr of this.treasures) {
            if (!tr.alive) continue;
            const g = Math.sin(tr.glow)*0.3+0.7;
            const r = Math.round(tr.r*g);
            ctx.fillStyle = rgba(TREASURE_C, 0.16);
            ctx.beginPath(); ctx.arc(tr.x, tr.y, r*2, 0, Math.PI*2); ctx.fill();
            fillCircle(tr.x, tr.y, r, TREASURE_C);
            strokeCircle(tr.x, tr.y, r, GOLD_C, 2);
            fillCircle(tr.x-3, tr.y-3, Math.max(1, Math.floor(r/3)), WHITE);
        }
        for (const p of this.particles) p.draw();
        const tl = Math.max(0, this.timer/60);
        fillText(`ì‹¬í•´ ë³´ë„ˆìŠ¤! ${tl.toFixed(1)}ì´ˆ  ë³´ë¬¼: ${this.collected}/${this.total}`,
            WIDTH/2, 45, TREASURE_C, '20px "Malgun Gothic", sans-serif', 'center');
    }
}

// ============================================================
//  MAIN GAME
// ============================================================
class PinballGame {
    constructor() {
        this.state = 'menu';
        this._testMode = false;
        this._testRound = 1;
        this._testGold = 50;
        this._testCursor = 0; // 0=round, 1=gold, 2=start
        this.score = 0; this.lives = 3;
        this.high_score = parseInt(localStorage.getItem('pinball_high_score')) || 0;
        this.best_round = parseInt(localStorage.getItem('pinball_best_round')) || 0;
        this.tilt_cnt = 0; this.tilt_lock = false; this.tilt_x = 0;
        this.t = 0; this.multi = 1;
        this.combo = 0; this.combo_t = 0;

        // Roguelike
        this.round_num = 0; this.round_score = 0; this.round_target = 0;
        this.gold = 0; this.gold_earned = 0; this.round_clear_timer = 0;
        this.boss = null; this.boss_killed_gold = 0;
        this.shop_cursor = 0;
        this.shop_tab = 0; // 0=ê°•í™” ë½‘ê¸°, 1=ì†Œëª¨í’ˆ ë½‘ê¸°, 2=ê³µ ë½‘ê¸°, 3=ìœ ë¬¼ ë½‘ê¸°
        this.upgrades = {};
        for (const item of SHOP_ITEMS) this.upgrades[item.id] = 0;
        this.upgrade_choices = null; // [item, item] two choices
        this.upgrade_pick = 0; // 0 or 1
        this.upgrade_draw_count = 0; // ê°•í™” ë½‘ê¸° íšŸìˆ˜ (ë¹„ìš© ì¦ê°€ìš©)

        // Consumables inventory (persists across rounds, max 2 slots)
        this.consumable_inv = []; // array of consumable ids in inventory
        this.consumable_max = 2;
        this.consumable_draw_result = null; // last drawn consumable
        this.consumable_draw_timer = 0;
        this.consumable_open = false; // pause menu open
        this.consumable_cursor = 0; // selected slot in pause menu
        this.deep_sea_timer = 0;
        this.shield_count = 0;
        this.slow_time_timer = 0;
        this.combo_master = false;

        // Ball gacha (3 slots: main, 2nd, 3rd)
        this.ball_slots = [null, null, null];
        this.current_ball_type = null; // alias for ball_slots[0]
        this.gacha_result = null; this.gacha_result_timer = 0;

        // Relics (permanent passives)
        this.relics = {};
        this.relic_result = null; this.relic_result_timer = 0;
        this.relic_bought_ante = 0; // í˜„ìž¬ ì•¤í‹°ì—ì„œ êµ¬ë§¤í•œ ìœ ë¬¼ ìˆ˜
        this.relic_choices = null; // [relic, relic] two choices
        this.relic_pick = 0;

        // Next round hold timer (prevent accidental skip)
        this._nextRoundHold = 0;
        this._nextRoundHolding = false;
        this._nextRoundTouchId = null;
        this._nextRoundRequired = 60; // frames (1 second)
        this._stateChangeCooldown = 0; // prevent touch leaking between states

        // Upgrade computed
        this.gravity_val = GRAVITY;
        this.flipper_power_val = 1.0;
        this.base_multi = 1.0;
        this.bumper_mult_val = 1.0;

        this.balls = [];
        this.lf = new Flipper(140, 735, 'left');
        this.rf = new Flipper(360, 735, 'right');
        this.plunger = new Plunger();
        this.ball_in_p = false;

        this.bumpers = [
            new Bumper(180, 250, 22, 'puffer', 100),
            new Bumper(300, 220, 22, 'jelly', 150),
            new Bumper(240, 330, 22, 'puffer', 100),
        ];
        this.pin = new Pin(250, 755, 5, 50);  // drain saver dot
        this.slings = [
            new Slingshot(55, 610, 120, 700),
            new Slingshot(420, 610, 380, 700),
        ];
        this.drops = []; this._reset_drops();
        this.spinner = new Spinner(250, 470);
        this.bonus = new BonusStage();
        this.bonus_th = 50000; this.next_bonus = this.bonus_th;

        this.particles = [];
        this.bubbles = [];
        for (let i=0;i<25;i++) this.bubbles.push(new Bubble());
        this.popups = [];
        this.multiball = false; this.multiball_t = 0;

        // Keys
        this.keys = {};
        this._setupInput();
    }

    _setupInput() {
        document.addEventListener('keydown', e => {
            if (e.repeat) return;
            this.keys[e.code] = true;
            this._onKeyDown(e.code);
        });
        document.addEventListener('keyup', e => {
            this.keys[e.code] = false;
            this._onKeyUp(e.code);
        });
    }

    _onKeyDown(code) {
        if (!audioCtx) initAudio();

        if (this.state === 'menu') {
            if (code === 'Space') this._start();
            else if (code === 'KeyT') {
                this.state = 'test_setup';
                this._testRound = 1;
                this._testGold = 50;
                this._testCursor = 0;
            }
        } else if (this.state === 'test_setup') {
            if (code === 'ArrowUp') this._testCursor = (this._testCursor - 1 + 3) % 3;
            else if (code === 'ArrowDown') this._testCursor = (this._testCursor + 1) % 3;
            else if (code === 'ArrowLeft') {
                if (this._testCursor === 0) this._testRound = Math.max(1, this._testRound - 1);
                else if (this._testCursor === 1) this._testGold = Math.max(0, this._testGold - 10);
            } else if (code === 'ArrowRight') {
                if (this._testCursor === 0) this._testRound = Math.min(999, this._testRound + 1);
                else if (this._testCursor === 1) this._testGold = Math.min(9999, this._testGold + 10);
            } else if (code === 'Space' || code === 'Enter') {
                if (this._testCursor === 2) this._startTest();
            } else if (code === 'Escape') {
                this.state = 'menu';
            }
        } else if (this.state === 'gameover' || this.state === 'victory') {
            if (code === 'Space') this.state = 'menu';
        } else if (this.state === 'round_clear') {
            if (code === 'Space') this.round_clear_timer = 0;
        } else if (this.state === 'shop') {
            // If upgrade choices are shown, handle pick
            if (this.upgrade_choices) {
                const maxPick = this.upgrade_choices.length - 1;
                if (code === 'ArrowLeft') this.upgrade_pick = Math.max(0, this.upgrade_pick - 1);
                else if (code === 'ArrowRight') this.upgrade_pick = Math.min(maxPick, this.upgrade_pick + 1);
                else if (code === 'Space' || code === 'Enter') this._upgrade_pick_confirm();
                return; // must pick one, no cancel
            }
            // If relic choices are shown, handle pick
            if (this.relic_choices) {
                const maxPick = this.relic_choices.length - 1;
                if (code === 'ArrowLeft') this.relic_pick = Math.max(0, this.relic_pick - 1);
                else if (code === 'ArrowRight') this.relic_pick = Math.min(maxPick, this.relic_pick + 1);
                else if (code === 'Space' || code === 'Enter') this._relic_pick_confirm();
                return; // must pick one, no cancel
            }
            const tabCounts = [1, 1, 3, 1]; // items per tab (draw buttons; gacha has 3 slots)
            const total = tabCounts[this.shop_tab];
            if (code === 'ArrowUp') this.shop_cursor = (this.shop_cursor - 1 + total) % total;
            else if (code === 'ArrowDown') this.shop_cursor = (this.shop_cursor + 1) % total;
            else if (code === 'ArrowLeft') { this.shop_tab = (this.shop_tab - 1 + 4) % 4; this.shop_cursor = 0; }
            else if (code === 'ArrowRight') { this.shop_tab = (this.shop_tab + 1) % 4; this.shop_cursor = 0; }
            else if (code === 'Space') this._shop_buy();
            else if (code === 'Enter') this._nextRoundHolding = true;
        } else if (this.state === 'play') {
            // Consumable pause menu
            if (this.consumable_open) {
                if (code === 'Escape' || code === 'KeyQ' || code === 'Tab') {
                    this.consumable_open = false;
                } else if (code === 'ArrowLeft') {
                    this.consumable_cursor = Math.max(0, this.consumable_cursor - 1);
                } else if (code === 'ArrowRight') {
                    this.consumable_cursor = Math.min(this.consumable_inv.length - 1, this.consumable_cursor);
                    if (this.consumable_cursor < this.consumable_inv.length - 1) this.consumable_cursor++;
                } else if (code === 'Space' || code === 'Enter') {
                    if (this.consumable_inv.length > 0 && this.consumable_cursor < this.consumable_inv.length) {
                        this._use_consumable(this.consumable_cursor);
                        if (this.consumable_inv.length > 0)
                            this.consumable_cursor = Math.min(this.consumable_cursor, this.consumable_inv.length - 1);
                    }
                } else if (code === 'KeyM') {
                    // ë©”ì¸ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                    this.consumable_open = false;
                    this.state = 'menu';
                }
                return; // block other play inputs while menu is open
            }

            if (code === 'KeyQ' || code === 'Tab') {
                this.consumable_open = true;
                this.consumable_cursor = 0;
                return;
            }
            if (code === 'KeyZ' || code === 'ShiftLeft') { this._flipper_on('left'); }
            if (code === 'Slash' || code === 'ShiftRight') { this._flipper_on('right'); }
            if (code === 'Space' && this.ball_in_p) this.plunger.charging = true;
            if (code === 'ArrowLeft' && !this.tilt_lock) { this.tilt_x = -0.15; this.tilt_cnt++; }
            if (code === 'ArrowRight' && !this.tilt_lock) { this.tilt_x = 0.15; this.tilt_cnt++; }
            if (this.tilt_cnt >= 5) { this.tilt_lock = true; this.tilt_x = 0; }
        }
    }

    _onKeyUp(code) {
        if (code === 'Enter') { this._nextRoundHolding = false; this._nextRoundHold = 0; }
        if (this.state === 'play') {
            if (code === 'KeyZ' || code === 'ShiftLeft') this._flipper_off('left');
            if (code === 'Slash' || code === 'ShiftRight') this._flipper_off('right');
            if (code === 'Space') {
                if (this.ball_in_p && this.plunger.charging) {
                    for (const b of this.balls) {
                        if (Math.abs(b.x - this.plunger.x) < 20 && b.y > 700) {
                            b.vy = this.plunger.launch_speed();
                            b.vx = randUniform(-0.5, 0.5);
                        }
                    }
                    this.ball_in_p = false;
                    this.plunger.charging = false;
                    sndLaunch();
                }
            }
            if (code === 'ArrowLeft' || code === 'ArrowRight') this.tilt_x = 0;
        }
    }

    _reset_drops() {
        this.drops = [];
        const layout = this._current_map_drops || null;
        if (layout) {
            for (const d of layout) this.drops.push(new DropTarget(d[0], d[1], d[2], d[3]));
        } else {
            for (let i=0;i<5;i++)
                this.drops.push(new DropTarget(130+i*60, 430-Math.abs(i-2)*15, FISH_COL[i], 200));
        }
    }

    _setup_map(ante) {
        // Different map layouts per ante
        const maps = [
            // Ante 1: ê¸°ë³¸ ë°°ì¹˜
            {
                bumpers: [
                    [180, 250, 22, 'puffer', 100],
                    [300, 220, 22, 'jelly', 150],
                    [240, 330, 22, 'puffer', 100],
                ],
                drops: [[130,430,FISH_COL[0],200],[190,415,FISH_COL[1],200],[250,400,FISH_COL[2],200],[310,415,FISH_COL[3],200],[370,430,FISH_COL[4],200]],
                spinner: [250, 470],
                pin: [250, 755, 5, 50],
            },
            // Ante 2: ë²”í¼ ë„“ê²Œ, ë“œë¡­ ë†’ì´
            {
                bumpers: [
                    [130, 230, 22, 'jelly', 150],
                    [350, 230, 22, 'puffer', 150],
                    [240, 310, 25, 'puffer', 120],
                ],
                drops: [[100,380,FISH_COL[1],200],[180,360,FISH_COL[3],200],[260,350,FISH_COL[0],200],[340,360,FISH_COL[4],200],[420,380,FISH_COL[2],200]],
                spinner: [200, 480],
                pin: [250, 755, 5, 50],
            },
            // Ante 3: ì‚¬ê°í˜• ë°°ì¹˜
            {
                bumpers: [
                    [160, 220, 20, 'puffer', 100],
                    [320, 220, 20, 'puffer', 100],
                    [240, 280, 25, 'jelly', 180],
                    [160, 340, 20, 'puffer', 150],
                ],
                drops: [[140,440,FISH_COL[2],220],[220,420,FISH_COL[0],220],[300,420,FISH_COL[4],220],[380,440,FISH_COL[1],220]],
                spinner: [300, 490],
                pin: [250, 755, 5, 50],
            },
            // Ante 4: ì‚¼ê°í˜• + ì¤‘ì•™ ëŒ€í˜•
            {
                bumpers: [
                    [240, 200, 28, 'jelly', 200],
                    [150, 320, 22, 'puffer', 120],
                    [330, 320, 22, 'puffer', 120],
                ],
                drops: [[110,420,FISH_COL[3],250],[190,400,FISH_COL[1],250],[270,390,FISH_COL[0],250],[350,400,FISH_COL[4],250],[430,420,FISH_COL[2],250]],
                spinner: [340, 470],
                pin: [250, 755, 5, 50],
            },
            // Ante 5: ë‹¤ì´ì•„ëª¬ë“œ
            {
                bumpers: [
                    [240, 190, 22, 'puffer', 130],
                    [160, 280, 22, 'jelly', 170],
                    [320, 280, 22, 'puffer', 170],
                    [240, 360, 22, 'puffer', 130],
                ],
                drops: [[130,450,FISH_COL[0],250],[210,430,FISH_COL[2],250],[290,430,FISH_COL[4],250],[370,450,FISH_COL[1],250]],
                spinner: [180, 490],
                pin: [250, 755, 5, 50],
            },
            // Ante 6: ë°€ì§‘ ë°°ì¹˜
            {
                bumpers: [
                    [180, 230, 20, 'puffer', 160],
                    [300, 230, 20, 'jelly', 160],
                    [240, 300, 22, 'puffer', 140],
                    [180, 370, 20, 'puffer', 140],
                    [300, 370, 20, 'puffer', 180],
                ],
                drops: [[120,440,FISH_COL[4],280],[200,425,FISH_COL[2],280],[280,420,FISH_COL[0],280],[360,425,FISH_COL[3],280]],
                spinner: [250, 480],
                pin: [250, 755, 5, 50],
            },
            // Ante 7: ì§€ê·¸ìž¬ê·¸
            {
                bumpers: [
                    [140, 220, 22, 'puffer', 150],
                    [280, 260, 25, 'jelly', 200],
                    [170, 340, 22, 'puffer', 180],
                    [340, 310, 22, 'puffer', 150],
                ],
                drops: [[100,430,FISH_COL[1],300],[180,400,FISH_COL[3],300],[260,410,FISH_COL[0],300],[340,400,FISH_COL[4],300],[420,430,FISH_COL[2],300]],
                spinner: [320, 490],
                pin: [250, 755, 5, 50],
            },
            // Ante 8: ìµœì¢… - ëŒ€í˜• ë°°ì¹˜
            {
                bumpers: [
                    [180, 210, 24, 'puffer', 200],
                    [310, 210, 24, 'puffer', 200],
                    [130, 310, 20, 'puffer', 160],
                    [360, 310, 20, 'puffer', 160],
                    [240, 360, 26, 'jelly', 250],
                ],
                drops: [[110,440,FISH_COL[0],350],[190,420,FISH_COL[2],350],[270,415,FISH_COL[4],350],[350,420,FISH_COL[1],350],[430,440,FISH_COL[3],350]],
                spinner: [240, 490],
                pin: [250, 755, 5, 50],
            },
        ];

        const idx = Math.min(ante - 1, maps.length - 1);
        const m = maps[idx];

        this.bumpers = m.bumpers.map(b => new Bumper(b[0], b[1], b[2], b[3], b[4]));
        this._current_map_drops = m.drops;
        this.spinner = new Spinner(m.spinner[0], m.spinner[1]);
        const pinR = m.pin[2] * (this.relics.big_pin ? 1.6 : 1);
        this.pin = new Pin(m.pin[0], m.pin[1], pinR, m.pin[3]);
    }

    _spawn_plunger() {
        const slotIdx = Math.min(this.ball_launch_index || 0, 2);
        const ballType = this.ball_slots[slotIdx];
        this.current_ball_type = ballType; // ê¸€ë¡œë²Œ íš¨ê³¼ë¥¼ í˜„ìž¬ ê³µì— ë§žì¶¤
        this.balls.push(new Ball(this.plunger.x, 720, 0, 0, ballType));
        this.ball_in_p = true;
    }

    _get_ante(n=null) {
        if (n === null) n = this.round_num;
        return Math.ceil(n / 3);
    }
    _get_stage(n=null) {
        if (n === null) n = this.round_num;
        return ((n - 1) % 3) + 1; // 1, 2, 3
    }
    _is_boss_round(n=null) {
        return this._get_stage(n) === 3;
    }

    _get_round_target(n=null) {
        if (n === null) n = this.round_num;
        const base = ROUND_BASE_TARGET + (n-1)*ROUND_SCALE + Math.floor(Math.pow(n-1, 1.5)*200);
        return this._testMode ? Math.floor(base / 5) : base;
    }

    _apply_upgrades() {
        const lv = this.upgrades;
        this.gravity_val = GRAVITY * (1 - 0.08*lv.gravity);
        this.flipper_power_val = 1.0 + 0.15*lv.flipper_power;
        this.base_multi = 1.0 + 0.2*lv.score_boost;
        this.bumper_mult_val = 1.0 + 0.3*lv.bumper_bonus;
        const newLen = FLIP_LEN + lv.flipper_size*5;
        this.lf.length = newLen; this.rf.length = newLen;
    }

    _start() {
        this._testMode = false;
        this.score = 0; this.lives = 3;
        this.round_num = 0; this.gold = 0;
        this.upgrades = {};
        for (const item of SHOP_ITEMS) this.upgrades[item.id] = 0;
        this.consumable_inv = []; this.deep_sea_timer = 0;
        this.consumable_draw_result = null; this.consumable_draw_timer = 0;
        this.shield_count = 0; this.slow_time_timer = 0; this.combo_master = false;
        this.ball_slots = [null, null, null];
        this.current_ball_type = null;
        this.gacha_result = null; this.gacha_result_timer = 0;
        this.relics = {};
        this.relic_result = null; this.relic_result_timer = 0;
        this.relic_choices = null; this.relic_pick = 0;
        this.shop_cursor = 0; this.shop_tab = 0;
        this.upgrade_choices = null; this.upgrade_pick = 0; this._upgradeCooldown = 0;
        this.tilt_cnt = 0; this.tilt_lock = false; this.tilt_x = 0;
        this.multi = 1; this.combo = 0; this.combo_t = 0;
        this.next_bonus = this.bonus_th;
        this.multiball = false; this.multiball_t = 0;
        this._apply_upgrades();
        this._start_round();
    }

    _startTest() {
        this._testMode = true;
        this.score = 0; this.lives = 3;
        this.round_num = Math.max(0, this._testRound - 1); // _start_round will increment
        this.gold = this._testGold + (this._testMoney || 0);
        this.upgrades = {};
        for (const item of SHOP_ITEMS) this.upgrades[item.id] = 0;
        this.consumable_inv = []; this.deep_sea_timer = 0;
        this.consumable_draw_result = null; this.consumable_draw_timer = 0;
        this.upgrade_choices = null; this.upgrade_pick = 0; this._upgradeCooldown = 0;
        this.shield_count = 0; this.slow_time_timer = 0; this.combo_master = false;
        this.ball_slots = [null, null, null];
        this.current_ball_type = null;
        this.gacha_result = null; this.gacha_result_timer = 0;
        this.relics = {};
        this.relic_result = null; this.relic_result_timer = 0;
        this.relic_choices = null; this.relic_pick = 0;
        this.shop_cursor = 0; this.shop_tab = 0;
        this.tilt_cnt = 0; this.tilt_lock = false; this.tilt_x = 0;
        this.multi = 1; this.combo = 0; this.combo_t = 0;
        this.next_bonus = this.bonus_th;
        this.multiball = false; this.multiball_t = 0;
        this._apply_upgrades();
        this._start_round();
    }

    _start_round() {
        this.round_num++;

        // Check if we completed ante 8 â†’ victory!
        if (this._get_ante() > 8) {
            this.state = 'victory';
            if (!this._testMode) {
                if (this.score > this.high_score) {
                    this.high_score = this.score;
                    localStorage.setItem('pinball_high_score', this.high_score);
                }
                if (this.round_num - 1 > this.best_round) {
                    this.best_round = this.round_num - 1;
                    localStorage.setItem('pinball_best_round', this.best_round);
                }
            }
            return;
        }

        this.round_score = 0;
        this.round_bonus_gold = 0;
        this.round_target = this._get_round_target();
        this.lives = 3 + (this.relics.extra_life ? 1 : 0);
        this.ball_launch_index = 0; // í˜„ìž¬ ë°œì‚¬í•  ê³µ ìŠ¬ë¡¯ ì¸ë±ìŠ¤
        this.state = 'play';
        this.balls = [];
        this.tilt_cnt = 0; this.tilt_lock = false; this.tilt_x = 0;
        this.combo = 0; this.combo_t = 0;
        this.multiball = false; this.multiball_t = 0;
        this.multi = 1;
        this.boss_killed_gold = 0;

        // Reset active consumable effects (inventory persists)
        this.deep_sea_timer = 0;
        this.shield_count = 0;
        this.slow_time_timer = 0;
        this.combo_master = false;

        // Setup new map layout when ante changes (stage 1)
        if (this._get_stage() === 1 || this.round_num === 1) {
            this._setup_map(this._get_ante());
            this.relic_bought_ante = 0; // ì•¤í‹° ë³€ê²½ ì‹œ ìœ ë¬¼ êµ¬ë§¤ íšŸìˆ˜ ë¦¬ì…‹
        }

        // Spawn boss on boss rounds (stage 3 of each ante)
        if (this._is_boss_round()) {
            const ante = this._get_ante();
            this.boss = new Boss(WIDTH / 2, 180, ante);
        } else {
            this.boss = null;
        }

        this._reset_drops();
        this._spawn_plunger();
        this._apply_upgrades();
    }

    _complete_round() {
        const bt_eff = (this.current_ball_type || {}).effects || {};
        const gold_mult = bt_eff.gold_mult || 1.0;
        const alive_balls = this.balls.filter(b => b.active).length;
        const ball_bonus = alive_balls * 2; // +2G per remaining ball
        const bumper_gold = this.round_bonus_gold || 0;
        const boss_gold = this.boss_killed_gold || 0;
        const base_gold = GOLD_PER_ROUND + (this.relics.gold_rush ? 2 : 0);
        this.gold_earned = Math.floor((base_gold + bumper_gold + boss_gold) * gold_mult) + ball_bonus;
        this.bumper_gold_earned = bumper_gold;
        this.boss_gold_earned = boss_gold;
        this.ball_bonus_gold = ball_bonus;
        this.gold += this.gold_earned;
        this.state = 'round_clear';
        this.round_clear_timer = 150;
        if (!this._testMode && this.round_num > this.best_round) {
            this.best_round = this.round_num;
            localStorage.setItem('pinball_best_round', this.best_round);
        }
        sndRoundClear();
    }

    _add_score(pts, x, y) {
        const bt_eff = (this.current_ball_type || {}).effects || {};
        const ball_score_mult = bt_eff.score_mult || 1.0;
        const deep_sea_mult = this.deep_sea_timer > 0 ? 3.0 : 1.0;
        const actual = Math.floor(pts * this.multi * this.base_multi * ball_score_mult * deep_sea_mult);
        this.score += actual; this.round_score += actual;
        const has_mult = this.multi > 1 || this.base_multi > 1.0 || ball_score_mult > 1.0 || deep_sea_mult > 1;
        this.popups.push(new ScorePopup(x, y, `+${actual}`, has_mult ? GOLD_C : SCORE_C));
        const combo_ext = bt_eff.combo_extend || 1.0;
        const combo_master_mult = this.combo_master ? 2.0 : 1.0;
        const relic_combo = this.relics.combo_anchor ? 1.5 : 1.0;
        this.combo++; this.combo_t = Math.floor(120*combo_ext*combo_master_mult*relic_combo);
        if (this.score >= this.next_bonus && !this.bonus.active) {
            this.bonus.start(); this.next_bonus += this.bonus_th; sndBonus();
        }
    }

    _spawn_fx(x, y, col, cnt=8, spd=3, life=20, sz=3) {
        for (let i=0;i<cnt;i++) {
            const a = randUniform(0, 6.283);
            const s = randUniform(0.5, spd);
            this.particles.push(new Particle(x, y, s*Math.cos(a), s*Math.sin(a), col, randInt(Math.floor(life/2), life), sz));
        }
    }

    _flipper_on(side) {
        const debuff = this.boss ? this.boss.debuff : null;
        if (debuff === 'flip_lock_left' && side === 'left') return;
        if (debuff === 'flip_lock_right' && side === 'right') return;
        if (debuff === 'flip_reverse') {
            // Reversed: left input â†’ right flipper, right â†’ left
            if (side === 'left') { this.rf.on = true; sndFlip(); }
            else { this.lf.on = true; sndFlip(); }
        } else {
            if (side === 'left') { this.lf.on = true; sndFlip(); }
            else { this.rf.on = true; sndFlip(); }
        }
    }
    _flipper_off(side) {
        const debuff = this.boss ? this.boss.debuff : null;
        if (debuff === 'flip_reverse') {
            if (side === 'left') this.rf.on = false;
            else this.lf.on = false;
        } else {
            if (side === 'left') this.lf.on = false;
            else this.rf.on = false;
        }
    }

    _shop_buy() {
        if (this.shop_tab === 0) {
            // Upgrade draw - show 2 choices
            this._upgrade_draw();
        } else if (this.shop_tab === 1) {
            // Consumable gacha draw
            this._consumable_draw();
        } else if (this.shop_tab === 2) {
            // Gacha draw
            this._gacha_draw();
        } else if (this.shop_tab === 3) {
            // Relic draw
            this._relic_draw();
        }
    }

    _get_upgrade_cost() {
        return Math.min(UPGRADE_DRAW_COST + this.upgrade_draw_count, 15);
    }

    _upgrade_draw() {
        if (this.upgrade_choices) return; // already choosing
        if (this._upgradeCooldown > 0) return; // cooldown after pick
        const cost = this._get_upgrade_cost();
        if (this.gold < cost) return;
        // Check if any upgrades available
        const available = SHOP_ITEMS.filter(item => this.upgrades[item.id] < item.max_lv);
        if (available.length === 0) return;

        this.gold -= cost;
        this.upgrade_draw_count++;

        // Pick 2 (or 3 with relic) random different upgrades
        const pick_count = 2 + (this.relics.triple_choice ? 1 : 0);
        const shuffled = [...available].sort(() => Math.random() - 0.5);
        const picks = shuffled.slice(0, Math.min(pick_count, shuffled.length));

        this.upgrade_choices = picks;
        this.upgrade_pick = 0;
        sndBuy();
    }

    _upgrade_pick_confirm() {
        if (!this.upgrade_choices) return;
        const chosen = this.upgrade_choices[this.upgrade_pick];
        if (!chosen) return;
        this.upgrades[chosen.id]++;
        this._apply_upgrades();
        this.upgrade_choices = null;
        this._upgradeCooldown = 15; // prevent immediate re-draw
    }

    _consumable_draw() {
        if (this.gold < CONSUMABLE_DRAW_COST) return;
        if (this.consumable_inv.length >= this.consumable_max) return;
        this.gold -= CONSUMABLE_DRAW_COST;

        // Weighted random pick
        const total_w = CONSUMABLES.reduce((s, c) => s + c.weight, 0);
        let roll = randUniform(0, total_w);
        let chosen = CONSUMABLES[0];
        for (const c of CONSUMABLES) {
            roll -= c.weight;
            if (roll <= 0) { chosen = c; break; }
        }

        this.consumable_inv.push(chosen.id);
        this.consumable_draw_result = chosen;
        this.consumable_draw_timer = 120; // 2 seconds
        sndBuy();
    }

    _use_consumable(slot) {
        if (this.state !== 'play') return;
        if (slot < 0 || slot >= this.consumable_inv.length) return;
        const cid = this.consumable_inv[slot];
        const cons = CONSUMABLES.find(c => c.id === cid);
        if (!cons) return;

        // Remove from inventory
        this.consumable_inv.splice(slot, 1);

        // Apply effect
        if (cid === 'deep_sea') {
            this.deep_sea_timer = 600; // 10s
            this._spawn_fx(WIDTH/2, HEIGHT/2, [60,180,255], 20, 5, 40, 4);
        } else if (cid === 'shield') {
            this.shield_count++;
            this._spawn_fx(WIDTH/2, HEIGHT/2, [100,255,200], 15, 4, 30, 3);
        } else if (cid === 'slow_time') {
            this.slow_time_timer = 480; // 8s
            this._spawn_fx(WIDTH/2, HEIGHT/2, [180,140,255], 15, 4, 30, 3);
        } else if (cid === 'combo_master') {
            this.combo_master = true;
            this._spawn_fx(WIDTH/2, HEIGHT/2, [255,160,60], 15, 4, 30, 3);
        } else if (cid === 'temp_life') {
            this.lives++;
            this._spawn_fx(WIDTH/2, HEIGHT/2, [255,100,120], 15, 4, 30, 3);
        }

        // Show popup
        this.popups.push(new ScorePopup(WIDTH/2, HEIGHT/2 - 30, `${cons.icon} ${cons.name}`, cons.color));
        sndBuy();
    }

    _gacha_draw() {
        if (this.gold < GACHA_COST) return;
        this.gold -= GACHA_COST;
        const drawable = BALL_TYPES.filter(bt => bt.weight > 0);
        const total_w = drawable.reduce((s, bt) => s + bt.weight, 0);
        let roll = randUniform(0, total_w);
        let chosen = drawable[0];
        let cumul = 0;
        for (const bt of drawable) {
            cumul += bt.weight;
            if (roll <= cumul) { chosen = bt; break; }
        }
        // Assign to selected slot (shop_cursor 0,1,2 in gacha tab)
        const slot = this.shop_cursor;
        this.ball_slots[slot] = chosen;
        this.current_ball_type = this.ball_slots[0]; // main ball = slot 0
        this.gacha_result = chosen;
        this.gacha_result_timer = 180;
        sndRoundClear();
    }

    _relic_draw() {
        if (this.relic_choices) return; // already choosing
        if (this.gold < RELIC_COST) return;
        if (this.relic_bought_ante >= 1) return; // ì•¤í‹°ë‹¹ 1íšŒ ì œí•œ
        const available = RELICS.filter(r => !this.relics[r.id]);
        if (available.length === 0) return;
        this.gold -= RELIC_COST;
        this.relic_bought_ante++;

        // Pick 2 random different relics (or 1 if only 1 available)
        const shuffled = [...available].sort(() => Math.random() - 0.5);
        const picks = shuffled.slice(0, Math.min(2, shuffled.length));
        this.relic_choices = picks;
        this.relic_pick = 0;
        sndBuy();
    }

    _relic_pick_confirm() {
        if (!this.relic_choices) return;
        const chosen = this.relic_choices[this.relic_pick];
        if (!chosen) return;
        this.relics[chosen.id] = true;
        this._apply_relics();
        this.relic_result = chosen;
        this.relic_result_timer = 180;
        this.relic_choices = null;
        sndRoundClear();
    }

    _apply_relics() {
        // extra_box: consumable_max
        this.consumable_max = 2 + (this.relics.extra_box ? 1 : 0);
        // big_pin: update pin radius immediately
        if (this.pin) {
            this.pin.r = (this.relics.big_pin ? 8 : 5);
        }
    }

    _update() {
        if (this.state === 'round_clear') {
            this.round_clear_timer--;
            if (this.round_clear_timer <= 0) {
                this.state = 'shop';
                this._nextRoundHold = 0;
                this._nextRoundHolding = false;
                this._nextRoundTouchId = null;
                this._stateChangeCooldown = 30; // 0.5s touch guard
            }
            return;
        }
        if (this.state === 'shop') {
            if (this._stateChangeCooldown > 0) this._stateChangeCooldown--;
            if (this._upgradeCooldown > 0) this._upgradeCooldown--;
            if (this.gacha_result_timer > 0) this.gacha_result_timer--;
            if (this.relic_result_timer > 0) this.relic_result_timer--;
            if (this.consumable_draw_timer > 0) this.consumable_draw_timer--;
            // Next round hold logic
            if (this._nextRoundHolding) {
                this._nextRoundHold++;
                if (this._nextRoundHold >= this._nextRoundRequired) {
                    this._nextRoundHold = 0;
                    this._nextRoundHolding = false;
                    this._nextRoundTouchId = null;
                    this._start_round();
                }
            } else {
                this._nextRoundHold = 0;
            }
            return;
        }
        if (this.state !== 'play') return;
        if (this.consumable_open) return; // paused while consumable menu is open
        this.t++;

        // Consumable timers countdown
        if (this.deep_sea_timer > 0) this.deep_sea_timer--;
        if (this.slow_time_timer > 0) this.slow_time_timer--;

        if (this.tilt_lock && this.t % 300 === 0) {
            this.tilt_lock = false;
            this.tilt_cnt = Math.max(0, this.tilt_cnt - 2);
        }
        if (this.combo_t > 0) this.combo_t--;
        else this.combo = 0;

        this.lf.update(); this.rf.update(); this.plunger.update();
        for (const b of this.bumpers) b.update();
        if (this.boss) {
            this.boss.update();
            if (this.boss.heal_flash === 29) { // just healed
                this._spawn_fx(this.boss.x, this.boss.y, [80,255,120], 15, 3, 25, 3);
                this.popups.push(new ScorePopup(this.boss.x, this.boss.y - this.boss.r - 10, 'ðŸ’š íšŒë³µ!', [80,255,120]));
            }
        }
        this.pin.update();
        for (const s of this.slings) s.update();
        for (const d of this.drops) d.update();
        this.spinner.update();

        if (this.multiball) {
            this.multi = 2; this.multiball_t--;
            if (this.multiball_t <= 0 || this.balls.length <= 1) { this.multiball = false; this.multi = 1; }
        }

        const tilt = this.tilt_lock ? 0 : this.tilt_x;
        const bt_eff = (this.current_ball_type || {}).effects || {};
        const slow_mult = this.slow_time_timer > 0 ? 0.5 : 1.0;
        const boss_grav = (this.boss && this.boss.debuff === 'gravity_up') ? 1.5 : 1.0;
        const ball_grav = this.gravity_val * (bt_eff.gravity_mult || 1.0) * slow_mult * boss_grav;

        const drained = [];
        const split_spawns = [];
        for (const ball of this.balls) {
            if (!ball.active) continue;

            if (this.ball_in_p && ball.y > 700 && Math.abs(ball.x - this.plunger.x) < 20) {
                ball.vx = 0; ball.vy = 0;
                ball.x = this.plunger.x; ball.y = 720;
                ball.update_trail(); continue;
            }

            const spd = Math.hypot(ball.vx, ball.vy);
            const n_steps = Math.max(4, Math.floor(spd / BALL_R) + 1);
            const sub_dt = 1.0 / n_steps;

            // Store flipper final angles for interpolation
            const lf_final = this.lf.angle, rf_final = this.rf.angle;
            const lf_prev = this.lf.prev_angle, rf_prev = this.rf.prev_angle;

            for (let si=0; si<n_steps; si++) {
                // Interpolate flipper angles for this substep
                const st = (si + 1) / n_steps;
                this.lf.angle = lf_prev + (lf_final - lf_prev) * st;
                this.rf.angle = rf_prev + (rf_final - rf_prev) * st;

                ball.step(tilt, sub_dt, ball_grav);

                if (ball.collide_walls(WALLS)) sndWall();

                if (ball.in_lane && ball.x < TABLE_R) ball.in_lane = false;

                if (!ball.in_lane && ball.x > TABLE_R && 35 < ball.y && ball.y < 685) {
                    ball.x = TABLE_R - BALL_R;
                    if (ball.vx > 0) ball.vx = -Math.abs(ball.vx)*0.5;
                }

                if (this.lf.collide_ball(ball, this.flipper_power_val))
                    this._spawn_fx(ball.x, ball.y, SHELL_P, 5, 2, 15, 2);
                if (this.rf.collide_ball(ball, this.flipper_power_val))
                    this._spawn_fx(ball.x, ball.y, SHELL_P, 5, 2, 15, 2);

                for (const bmp of this.bumpers) {
                    if (bmp.collide_ball(ball)) {
                        const bmp_pts = Math.floor(bmp.pts * this.bumper_mult_val * (bt_eff.bumper_mult || 1.0));
                        this._add_score(bmp_pts, bmp.x, bmp.y - 20);
                        this._spawn_fx(ball.x, ball.y, bmp.style==='puffer'?PUFFER_Y:JELLY_P, 10, 4, 20, 3);
                        sndBump();
                        // +0.5 gold per jellyfish hit (jelly_bounty doubles it)
                        if (bmp.style === 'jelly') {
                            const jellyGold = 0.5 * (this.relics.jelly_bounty ? 2 : 1);
                            this.round_bonus_gold += jellyGold;
                            this.popups.push(new ScorePopup(bmp.x + 20, bmp.y - 35, `+${jellyGold}G`, GOLD_C));
                        }
                        if ((bt_eff.split_chance || 0) > 0) {
                            if (Math.random() < bt_eff.split_chance) split_spawns.push([ball.x, ball.y, ball.ball_type]);
                        }
                    }
                }

                // Boss collision
                if (this.boss && this.boss.alive) {
                    if (this.boss.collide_ball(ball)) {
                        this._spawn_fx(ball.x, ball.y, [120,100,60], 8, 3, 18, 2);
                        this.popups.push(new ScorePopup(this.boss.x, this.boss.y - this.boss.r - 25,
                            `HP -1 (${this.boss.hp}/${this.boss.max_hp})`, [255, 200, 80]));
                        sndBump();
                        if (!this.boss.alive) {
                            // Boss defeated!
                            this.boss_killed_gold = BOSS_GOLD_REWARD;
                            this.popups.push(new ScorePopup(this.boss.x, this.boss.y - 40, `+${BOSS_GOLD_REWARD}G BOSS!`, GOLD_C));
                            this._spawn_fx(this.boss.x, this.boss.y, [200,180,100], 30, 6, 40, 4);
                        }
                    }
                }

                // Drain saver pin
                if (this.pin.collide_ball(ball)) {
                    this._add_score(this.pin.pts, this.pin.x, this.pin.y - 10);
                    this._spawn_fx(ball.x, ball.y, [200,220,240], 4, 2, 10, 1);
                    sndWall();
                }

                if (!bt_eff.ghost) {
                    for (const sl of this.slings) {
                        if (sl.collide_ball(ball)) {
                            this._add_score(sl.pts, (sl.x1+sl.x2)/2, (sl.y1+sl.y2)/2-15);
                            this._spawn_fx(ball.x, ball.y, CORAL_C, 6, 3, 15, 2);
                            sndWall();
                        }
                    }
                }

                for (const dt of this.drops) {
                    if (dt.collide_ball(ball)) {
                        this._add_score(dt.pts, dt.x, dt.y-15);
                        this._spawn_fx(dt.x, dt.y, dt.color, 12, 4, 25, 3);
                        sndTarget();
                    }
                }

                if (this.spinner.collide_ball(ball)) {
                    this._add_score(this.spinner.pts, this.spinner.x, this.spinner.y-20);
                    sndSpin();
                }
            }

            // Restore final flipper angles after substep interpolation
            this.lf.angle = lf_final;
            this.rf.angle = rf_final;

            ball.update_trail();

            // Magnet
            if (bt_eff.magnet && ball.y > 600 && !ball.in_lane) {
                const center_x = 250;
                const drain_factor = Math.min(1.0, (ball.y - 600)/150);
                const pull = (center_x - ball.x) * (0.012 + 0.008*drain_factor);
                ball.vx += pull;
                if (ball.y > 680) ball.vy *= 0.97;
                if (this.t % 3 === 0) this._spawn_fx(ball.x, ball.y, [255,80,80], 3, 1, 8, 1);
            }

            if (ball.in_lane && ball.y > 700 && Math.abs(ball.x - this.plunger.x) < 30) {
                ball.vx = 0; ball.vy = 0;
                ball.x = this.plunger.x; ball.y = 720;
                this.ball_in_p = true;
            }

            if (ball.y > HEIGHT + 20) { ball.active = false; drained.push(ball); }
        }

        for (const [sx, sy, sbt] of split_spawns) {
            this.balls.push(new Ball(sx, sy, randUniform(-3,3), randUniform(-4,-1), sbt));
            this._spawn_fx(sx, sy, [180,100,255], 8, 3, 15, 2);
        }

        if (this.drops.every(d => !d.alive)) {
            if (!this.multiball) {
                this.multiball = true; this.multiball_t = 600;
                for (let i=0;i<2;i++) {
                    this.balls.push(new Ball(randUniform(100,350), 100, randUniform(-2,2), randUniform(1,3), this.current_ball_type));
                }
                this._spawn_fx(250, 300, GLOW_C, 30, 5, 40, 4);
                sndMulti();
            }
            this._reset_drops();
        }

        this.balls = this.balls.filter(b => b.active);
        if (drained.length > 0 && this.balls.length === 0) {
            // Shield: prevent drain once
            if (this.shield_count > 0) {
                this.shield_count--;
                this._spawn_plunger();
                this._spawn_fx(WIDTH/2, HEIGHT - 40, [100,255,200], 20, 4, 30, 4);
                this.popups.push(new ScorePopup(WIDTH/2, HEIGHT - 60, 'ðŸ›¡ï¸ ë°©ì–´ë§‰!', [100,255,200]));
                // skip life loss
            } else {
            this.lives--;
            this.ball_launch_index++; // ë‹¤ìŒ ê³µ ìŠ¬ë¡¯ìœ¼ë¡œ
            sndDrain();
            if (this.lives <= 0) {
                this.state = 'gameover';
                if (!this._testMode && this.score > this.high_score) {
                    this.high_score = this.score;
                    localStorage.setItem('pinball_high_score', this.high_score);
                }
                if (!this._testMode && this.round_num > this.best_round) {
                    this.best_round = this.round_num;
                    localStorage.setItem('pinball_best_round', this.best_round);
                }
            } else {
                this._spawn_plunger();
            }
            } // end shield else
        }

        if (this.bonus.active) {
            const bp = this.bonus.update(this.balls);
            if (bp > 0) { this.score += bp; this.round_score += bp; }
            if (!this.bonus.active && this.bonus.collected >= Math.floor(this.bonus.total/2)) {
                this.lives = Math.min(this.lives+1, 9);
                this.popups.push(new ScorePopup(WIDTH/2, HEIGHT/2, "ì¶”ê°€ ìƒëª…!", GOLD_C));
            }
        }

        this.particles = this.particles.filter(p => p.update());
        this.popups = this.popups.filter(p => p.update());
        for (const b of this.bubbles) b.update(this.t);

        // Round clear condition: boss round = kill boss, normal = reach target score
        if (this.boss) {
            if (!this.boss.alive && this.boss.death_t <= 0) this._complete_round();
        } else {
            if (this.round_score >= this.round_target) this._complete_round();
        }
    }

    // ============================================================
    //  DRAWING
    // ============================================================
    _draw_bg() {
        fillRect(0, 0, WIDTH, HEIGHT, BALATRO_BG_BASE);
        const cx = WIDTH/2, cy = HEIGHT/2;
        for (let i=0; i<8; i++) {
            const t_off = this.t*0.004 + i*0.6;
            const rad = 80 + i*45 + Math.sin(t_off)*40;
            const ang = t_off*0.4 + i;
            const c = lerp_col([55,110,160],[90,155,200], (Math.sin(t_off)+1)/2);
            ctx.strokeStyle = rgb(c); ctx.lineWidth = 35;
            ctx.beginPath();
            for (let j=0; j<20; j++) {
                const a = ang + j*0.3;
                const r = rad + Math.sin(a*3+this.t*0.015)*25;
                const px = cx+r*Math.cos(a), py = cy+r*Math.sin(a);
                if (j===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
            }
            ctx.closePath(); ctx.stroke();
        }
        // Grid
        const grid_off = (this.t*0.4)%40;
        ctx.strokeStyle = rgb([60,120,165]); ctx.lineWidth = 1;
        for (let x = Math.floor(grid_off)-40; x < WIDTH; x+=40) {
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke();
        }
        for (let y = Math.floor(grid_off)-40; y < HEIGHT; y+=40) {
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); ctx.stroke();
        }
        for (const b of this.bubbles) b.draw();
    }

    _draw_walls() {
        for (const [[x1,y1],[x2,y2]] of WALLS) {
            drawLine(x1,y1,x2,y2,[40,80,140],3);
            drawLine(x1,y1,x2,y2,[80,140,200],1);
        }
    }

    _draw_ui() {
        // Top bar
        ctx.fillStyle = 'rgba(20,40,80,0.7)';
        ctx.fillRect(0, 0, WIDTH, 36);
        drawLine(0, 36, WIDTH, 36, BALATRO_BLUE, 1);

        const ante = this._get_ante();
        const stage = this._get_stage();
        const isBoss = this._is_boss_round();
        fillText(`ANTE ${ante} - ${stage}/3${isBoss ? ' ðŸ—‘ï¸BOSS' : ''}`, 8, 15, isBoss ? [255,180,80] : BALATRO_GOLD, '14px "Malgun Gothic", sans-serif', 'left');
        if (this._testMode) fillText("TEST", 8, 32, BALATRO_ORANGE, '10px "Malgun Gothic", sans-serif', 'left');
        fillText(`${this.round_score.toLocaleString()}`, WIDTH/2, 18, WHITE, '20px "Malgun Gothic", sans-serif', 'center');

        let prog;
        if (this.boss) {
            const bossLabel = this.boss.alive ? `ðŸ—‘ï¸ HP ${this.boss.hp}/${this.boss.max_hp}` : 'ðŸ—‘ï¸ ì²˜ì¹˜!';
            fillText(bossLabel, WIDTH-8, 15, this.boss.alive ? [255,180,80] : [100,255,100], 'bold 14px "Malgun Gothic", sans-serif', 'right');
            prog = this.boss.alive ? 1 - (this.boss.hp / this.boss.max_hp) : 1;
        } else {
            fillText(`GOAL ${this.round_target.toLocaleString()}`, WIDTH-8, 15, [200,200,220], '14px "Malgun Gothic", sans-serif', 'right');
            prog = Math.min(1, this.round_score / Math.max(1, this.round_target));
        }
        const bar_w = WIDTH - 16;
        fillRect(8, 22, bar_w, 5, [15,30,60]);
        if (prog > 0) {
            const bar_col = this.boss ? lerp_col([180,60,40], [255,200,80], prog) : lerp_col(BALATRO_BLUE, BALATRO_GOLD, prog);
            fillRect(8, 22, Math.round(bar_w*prog), 5, bar_col);
        }
        ctx.strokeStyle = rgb([40,70,120]); ctx.lineWidth=1;
        ctx.strokeRect(8, 22, bar_w, 5);

        fillText(`TOTAL ${this.score.toLocaleString()}`, WIDTH/2, 33, [160,180,210], '12px "Malgun Gothic", sans-serif', 'center');

        // Boss debuff warning
        if (this.boss && this.boss.debuff && this.boss.alive) {
            const debuffNames = {
                'flip_lock_left': 'ðŸ”’ ì™¼ìª½ í”Œë¦¬í¼ ìž ê¸ˆ!',
                'flip_lock_right': 'ðŸ”’ ì˜¤ë¥¸ìª½ í”Œë¦¬í¼ ìž ê¸ˆ!',
                'flip_reverse': 'ðŸ”„ í”Œë¦¬í¼ ë°˜ì „!',
                'heal': 'ðŸ’š ì²´ë ¥ íšŒë³µ!',
                'gravity_up': 'â¬‡ï¸ ì¤‘ë ¥ ì¦ê°€!'
            };
            const dName = debuffNames[this.boss.debuff] || '';
            const flash = Math.sin(this.t * 0.2) > 0;
            if (flash) {
                ctx.fillStyle = 'rgba(180,40,40,0.6)';
                roundRect(WIDTH/2 - 80, 38, 160, 22, 6);
                ctx.fill();
                fillText(dName, WIDTH/2, 53, [255,220,180], 'bold 13px "Malgun Gothic", sans-serif', 'center');
            }
        }

        // Bottom bar
        const b_y = HEIGHT - 22;
        ctx.fillStyle = 'rgba(20,40,80,0.7)';
        ctx.fillRect(0, b_y, WIDTH, 22);
        drawLine(0, b_y, WIDTH, b_y, BALATRO_BLUE, 1);

        const bGold = this.round_bonus_gold || 0;
        fillText(`$${this.gold}  (+${bGold})`, 8, b_y+15, BALATRO_GOLD, '14px "Malgun Gothic", sans-serif', 'left');

        // Lives
        let lx = 65;
        for (let i=0; i<this.lives; i++) {
            fillCircle(lx+i*12, b_y+11, 4, BALATRO_RED);
            fillCircle(lx+i*12, b_y+11, 1, WHITE);
        }

        // Ball type
        const cbt = this.current_ball_type;
        const b_name = cbt ? cbt.name : "ê¸°ë³¸ ê³µ";
        const b_col = cbt ? cbt.color : PEARL;
        fillCircle(200, b_y+11, 5, b_col);
        fillText(b_name, 210, b_y+15, WHITE, '14px "Malgun Gothic", sans-serif', 'left');

        // Multiplier
        const t_mult = this.multi * this.base_multi;
        if (t_mult > 1.0) {
            fillText(`x${t_mult.toFixed(1)}`, WIDTH-10, b_y+15, BALATRO_ORANGE, '14px "Malgun Gothic", sans-serif', 'right');
        }

        // Consumable box button (top area) - always shown
        {
            const boxW = 80, boxH = 28, boxX = WIDTH/2 - boxW/2, boxY = 40;
            ctx.fillStyle = 'rgba(40,60,100,0.6)';
            ctx.strokeStyle = 'rgba(100,150,220,0.5)';
            ctx.lineWidth = 1;
            roundRect(boxX, boxY, boxW, boxH, 6);
            ctx.fill(); ctx.stroke();

            if (this.consumable_inv.length > 0) {
                // Mini icons
                const iconStartX = boxX + 6;
                for (let i = 0; i < Math.min(this.consumable_inv.length, 5); i++) {
                    const cid = this.consumable_inv[i];
                    const cons = CONSUMABLES.find(c => c.id === cid);
                    if (cons) fillText(cons.icon, iconStartX + i * 14, boxY + 18, WHITE, '11px "Malgun Gothic", sans-serif', 'left');
                }
            } else {
                fillText("ðŸ“¦ ë¹„ì–´ìžˆìŒ", boxX + 6, boxY + 18, [120,140,170], '10px "Malgun Gothic", sans-serif', 'left');
            }
            fillText(this._isMobile ? 'â–¼' : 'Q', boxX + boxW - 14, boxY + 18, [180,200,230], '11px "Malgun Gothic", sans-serif', 'center');
        }

        // Consumable pause menu overlay
        if (this.consumable_open) {
            // Dim background
            ctx.fillStyle = 'rgba(0,0,20,0.75)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            fillText("ì†Œëª¨í’ˆ ë°•ìŠ¤", WIDTH/2, 140, WHITE, 'bold 28px "Malgun Gothic", sans-serif', 'center');

            const cardW = 80, cardH = 120, cardGap = 10;
            const invLen = this.consumable_inv.length;

            if (invLen > 0) {
                fillText("ì‚¬ìš©í•  ì†Œëª¨í’ˆì„ ì„ íƒí•˜ì„¸ìš”", WIDTH/2, 168, [150,170,210], '14px "Malgun Gothic", sans-serif', 'center');

                const totalW = invLen * (cardW + cardGap) - cardGap;
                const startX = WIDTH/2 - totalW/2;
                const cardY = 210;

                for (let i = 0; i < invLen; i++) {
                    const cid = this.consumable_inv[i];
                    const cons = CONSUMABLES.find(c => c.id === cid);
                    if (!cons) continue;
                    const cx = startX + i * (cardW + cardGap);
                    const selected = (i === this.consumable_cursor);

                    // Card
                    const glow = selected ? 0.5 : 0.15;
                    ctx.fillStyle = `rgba(${cons.color[0]},${cons.color[1]},${cons.color[2]},${glow})`;
                    ctx.strokeStyle = selected
                        ? `rgba(${Math.min(255,cons.color[0]+80)},${Math.min(255,cons.color[1]+80)},${Math.min(255,cons.color[2]+80)},1)`
                        : `rgba(${cons.color[0]},${cons.color[1]},${cons.color[2]},0.5)`;
                    ctx.lineWidth = selected ? 3 : 1;
                    roundRect(cx, cardY, cardW, cardH, 10);
                    ctx.fill(); ctx.stroke();

                    // Selected glow
                    if (selected) {
                        ctx.shadowColor = `rgba(${cons.color[0]},${cons.color[1]},${cons.color[2]},0.6)`;
                        ctx.shadowBlur = 15;
                        roundRect(cx, cardY, cardW, cardH, 10);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }

                    // Icon large
                    fillText(cons.icon, cx + cardW/2, cardY + 40, WHITE, '30px "Malgun Gothic", sans-serif', 'center');
                    // Name
                    fillText(cons.name, cx + cardW/2, cardY + 70, selected ? WHITE : [200,200,220], 'bold 12px "Malgun Gothic", sans-serif', 'center');
                    // Desc
                    fillText(cons.desc, cx + cardW/2, cardY + 88, selected ? [220,220,240] : [140,160,190], '10px "Malgun Gothic", sans-serif', 'center');

                    // Selection indicator
                    if (selected) {
                        fillText("â–²", cx + cardW/2, cardY - 8, cons.color, 'bold 16px sans-serif', 'center');
                    }
                }

                // Empty slots
                for (let i = invLen; i < this.consumable_max; i++) {
                    const cx = startX + i * (cardW + cardGap);
                    ctx.fillStyle = 'rgba(30,40,60,0.3)';
                    ctx.strokeStyle = 'rgba(60,70,90,0.3)';
                    ctx.lineWidth = 1;
                    roundRect(cx, cardY, cardW, cardH, 10);
                    ctx.fill(); ctx.stroke();
                }

                // Bottom hint
                const sel_cons = CONSUMABLES.find(c => c.id === this.consumable_inv[this.consumable_cursor]);
                if (sel_cons) {
                    fillText(`[ Space ] ${sel_cons.name} ì‚¬ìš©`, WIDTH/2, 380, sel_cons.color, 'bold 16px "Malgun Gothic", sans-serif', 'center');
                }
            } else {
                // Empty inventory message
                fillText("ðŸ“¦", WIDTH/2, 230, WHITE, '48px "Malgun Gothic", sans-serif', 'center');
                fillText("ì†Œëª¨í’ˆì´ ì—†ìŠµë‹ˆë‹¤", WIDTH/2, 280, [150,170,210], '18px "Malgun Gothic", sans-serif', 'center');
                fillText("ìƒì ì—ì„œ ì†Œëª¨í’ˆì„ ë½‘ì•„ë³´ì„¸ìš”!", WIDTH/2, 305, [120,140,170], '13px "Malgun Gothic", sans-serif', 'center');
            }

            // "ë©”ì¸ í™”ë©´ìœ¼ë¡œ" button (always shown)
            const menuBtnX = WIDTH/2 - 70, menuBtnY = 470, menuBtnW = 140, menuBtnH = 40;
            ctx.fillStyle = 'rgba(40,60,100,0.7)';
            ctx.strokeStyle = 'rgba(100,150,220,0.6)';
            ctx.lineWidth = 1;
            roundRect(menuBtnX, menuBtnY, menuBtnW, menuBtnH, 8);
            ctx.fill(); ctx.stroke();
            fillText("ðŸ  ë©”ì¸ í™”ë©´ìœ¼ë¡œ", WIDTH/2, menuBtnY + menuBtnH/2 + 6, [200,220,255], 'bold 15px "Malgun Gothic", sans-serif', 'center');

            if (this._isMobile) {
                // Close button
                const clX = WIDTH/2 - 60, clY = 430, clW = 120, clH = 40;
                ctx.fillStyle = 'rgba(80,40,40,0.7)';
                ctx.strokeStyle = 'rgba(180,80,80,0.6)';
                ctx.lineWidth = 1;
                roundRect(clX, clY, clW, clH, 8);
                ctx.fill(); ctx.stroke();
                fillText("ë‹«ê¸°", WIDTH/2, clY + clH/2 + 6, WHITE, 'bold 16px "Malgun Gothic", sans-serif', 'center');
            } else {
                fillText("[ â†â†’ ] ì„ íƒ   [ Space ] ì‚¬ìš©   [ M ] ë©”ì¸ìœ¼ë¡œ   [ Q / ESC ] ë‹«ê¸°", WIDTH/2, 420, [120,140,180], '12px "Malgun Gothic", sans-serif', 'center');
            }

            fillText("â¸ ì¼ì‹œì •ì§€", WIDTH/2, 110, [200,200,100], '14px "Malgun Gothic", sans-serif', 'center');
        }

        // Active consumable effects overlay
        if (this.deep_sea_timer > 0) {
            const sec = Math.ceil(this.deep_sea_timer / 60);
            const alpha = Math.min(1, 0.15 + Math.sin(this.t * 0.05) * 0.05);
            ctx.fillStyle = `rgba(0,80,200,${alpha.toFixed(2)})`;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            fillText(`ðŸŒŠ ì‹¬í•´ x3 (${sec}s)`, WIDTH/2, 55, [100,200,255], 'bold 14px "Malgun Gothic", sans-serif', 'center');
        }
        if (this.slow_time_timer > 0) {
            const sec = Math.ceil(this.slow_time_timer / 60);
            const alpha = Math.min(1, 0.08 + Math.sin(this.t * 0.03) * 0.03);
            ctx.fillStyle = `rgba(100,60,200,${alpha.toFixed(2)})`;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            const yOff = this.deep_sea_timer > 0 ? 72 : 55;
            fillText(`ðŸŒ ìŠ¬ë¡œìš° (${sec}s)`, WIDTH/2, yOff, [180,150,255], 'bold 14px "Malgun Gothic", sans-serif', 'center');
        }

        // Status icons on right side
        {
            let iy = 55;
            if (this.shield_count > 0) {
                fillText(`ðŸ›¡ï¸x${this.shield_count}`, WIDTH - 10, iy, [100,255,200], '13px "Malgun Gothic", sans-serif', 'right');
                iy += 18;
            }
            if (this.combo_master) {
                fillText('ðŸ”¥ì½¤ë³´+', WIDTH - 10, iy, [255,160,60], '13px "Malgun Gothic", sans-serif', 'right');
                iy += 18;
            }
        }

        // Overlay warnings
        if (this.multiball) {
            fillText("MULTIBALL!", WIDTH/2, 105, BALATRO_BLUE, '20px "Malgun Gothic", sans-serif', 'center');
        }
        if (this.tilt_lock) {
            fillText("TILT!", WIDTH/2, HEIGHT/2, BALATRO_RED, '20px "Malgun Gothic", sans-serif', 'center');
        } else if (this.tilt_cnt >= 3) {
            fillText("WARNING", WIDTH/2, 105, BALATRO_ORANGE, '14px "Malgun Gothic", sans-serif', 'center');
        }
        if (this.combo > 2) {
            fillText(`COMBO x${this.combo}`, WIDTH/2, HEIGHT-40, BALATRO_ORANGE, '14px "Malgun Gothic", sans-serif', 'center');
        }
    }

    _draw_menu() {
        this._draw_bg();
        const title = "ë°”ë‹¤ í•€ë³¼";
        const chars = [...title];
        for (let i=0; i<chars.length; i++) {
            const yo = Math.sin(this.t*0.05+i*0.5)*8;
            fillText(chars[i], WIDTH/2 - chars.length*22 + i*44, 260+yo, WHITE, '42px "Malgun Gothic", sans-serif', 'left');
        }
        fillText("Ocean Pinball Roguelike", WIDTH/2, 310, SKY_SEA, '20px "Malgun Gothic", sans-serif', 'center');

        const desc_lines = ["ë¼ìš´ë“œë³„ ëª©í‘œ ì ìˆ˜ë¥¼ ë‹¬ì„±í•˜ì„¸ìš”!", "ë¼ìš´ë“œ í´ë¦¬ì–´ í›„ ìƒì ì—ì„œ ê°•í™”í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤."];
        for (let i=0; i<desc_lines.length; i++) {
            fillText(desc_lines[i], WIDTH/2, 350+i*20, [180,210,240], '14px "Malgun Gothic", sans-serif', 'center');
        }

        // Swimming fish
        const fx = WIDTH/2 + Math.sin(this.t*0.03)*80;
        const fy = 420;
        ctx.fillStyle = rgb(FISH_COL[0]);
        ctx.beginPath(); ctx.ellipse(fx, fy, 15, 8, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(fx-15,fy); ctx.lineTo(fx-25,fy-8); ctx.lineTo(fx-25,fy+8); ctx.closePath(); ctx.fill();
        fillCircle(fx+5, fy-2, 3, WHITE);
        fillCircle(fx+5, fy-2, 1, BLACK);

        if (Math.floor(this.t/40)%2) {
            fillText("ìŠ¤íŽ˜ì´ìŠ¤ í‚¤ë¥¼ ëˆŒëŸ¬ ì‹œìž‘", WIDTH/2, 470, WHITE, '20px "Malgun Gothic", sans-serif', 'center');
        }

        const ctrls = ["Z / ì™¼ìª½ Shift: ì™¼ìª½ í”Œë¦¬í¼", "/ / ì˜¤ë¥¸ìª½ Shift: ì˜¤ë¥¸ìª½ í”Œë¦¬í¼", "Space: ë°œì‚¬ (ê¾¹ ëˆ„ë¥´ê¸°)", "ë°©í–¥í‚¤: ê¸°ìš¸ì´ê¸° (ì£¼ì˜!)"];
        for (let i=0; i<ctrls.length; i++) {
            fillText(ctrls[i], WIDTH/2, 530+i*22, [150,180,220], '14px "Malgun Gothic", sans-serif', 'center');
        }
        if (this.high_score > 0) fillText(`ìµœê³  ì ìˆ˜: ${this.high_score.toLocaleString()}`, WIDTH/2, 660, GOLD_C, '14px "Malgun Gothic", sans-serif', 'center');
        if (this.best_round > 0) fillText(`ìµœê³  ë¼ìš´ë“œ: ${this.best_round}`, WIDTH/2, 680, GOLD_C, '14px "Malgun Gothic", sans-serif', 'center');

        // Test mode: T key only (hidden)
    }

    _draw_test_setup() {
        this._draw_bg();
        ctx.fillStyle = 'rgba(0,0,30,0.7)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        fillText("í…ŒìŠ¤íŠ¸ ëª¨ë“œ", WIDTH/2, 180, BALATRO_ORANGE, '36px "Malgun Gothic", sans-serif', 'center');
        fillText("ì›í•˜ëŠ” ì„¤ì •ìœ¼ë¡œ ê²Œìž„ì„ ì‹œìž‘í•©ë‹ˆë‹¤", WIDTH/2, 215, [180,180,210], '14px "Malgun Gothic", sans-serif', 'center');

        const items = [
            { label: "ë¼ìš´ë“œ", value: String(this._testRound) },
            { label: "ê³¨ë“œ", value: this._testGold + "G" },
            { label: "ê²Œìž„ ì‹œìž‘!", value: "" }
        ];

        const startY = 300;
        const gap = 70;
        const boxW = 360, boxH = 50;

        for (let i = 0; i < items.length; i++) {
            const y = startY + i * gap;
            const selected = (this._testCursor === i);
            const bx = WIDTH/2 - boxW/2, by = y - boxH/2;

            // Box background
            ctx.fillStyle = selected ? 'rgba(100,140,255,0.25)' : 'rgba(40,40,70,0.5)';
            ctx.strokeStyle = selected ? 'rgba(120,160,255,0.8)' : 'rgba(80,80,120,0.4)';
            ctx.lineWidth = selected ? 2 : 1;
            roundRect(bx, by, boxW, boxH, 8);
            ctx.fill(); ctx.stroke();

            if (i < 2) {
                // Label on left
                fillText(items[i].label, bx + 15, y + 5, selected ? WHITE : [180,180,210], '16px "Malgun Gothic", sans-serif', 'left');

                // - and + buttons
                const btnSize = 36;
                const valCenterX = bx + boxW - 90;

                // Minus button
                const minusBx = valCenterX - 70 - btnSize/2;
                ctx.fillStyle = selected ? 'rgba(200,80,80,0.4)' : 'rgba(80,60,60,0.3)';
                ctx.strokeStyle = selected ? 'rgba(255,120,120,0.6)' : 'rgba(120,80,80,0.3)';
                ctx.lineWidth = 1;
                roundRect(minusBx, y - btnSize/2, btnSize, btnSize, 6);
                ctx.fill(); ctx.stroke();
                fillText("âˆ’", minusBx + btnSize/2, y + 6, selected ? [255,150,150] : [140,100,100], 'bold 22px "Malgun Gothic", sans-serif', 'center');

                // Value display
                fillText(items[i].value, valCenterX, y + 6, selected ? GOLD_C : [200,200,230], 'bold 22px "Malgun Gothic", sans-serif', 'center');

                // Plus button
                const plusBx = valCenterX + 70 - btnSize/2;
                ctx.fillStyle = selected ? 'rgba(80,200,80,0.4)' : 'rgba(60,80,60,0.3)';
                ctx.strokeStyle = selected ? 'rgba(120,255,120,0.6)' : 'rgba(80,120,80,0.3)';
                ctx.lineWidth = 1;
                roundRect(plusBx, y - btnSize/2, btnSize, btnSize, 6);
                ctx.fill(); ctx.stroke();
                fillText("+", plusBx + btnSize/2, y + 6, selected ? [150,255,150] : [100,140,100], 'bold 22px "Malgun Gothic", sans-serif', 'center');
            } else {
                // Start button
                fillText(items[i].label, WIDTH/2, y + 5, selected ? BALATRO_ORANGE : [180,180,210], 'bold 20px "Malgun Gothic", sans-serif', 'center');
            }

            // Selection indicator (keyboard)
            if (selected && !this._isMobile) {
                fillText("â–¸", bx - 15, y + 5, BALATRO_BLUE, '20px "Malgun Gothic", sans-serif', 'center');
            }
        }

        // Back button (top-left)
        const backBtnW = 60, backBtnH = 30, backBx = 10, backBy = 15;
        ctx.fillStyle = 'rgba(60,60,90,0.7)';
        ctx.strokeStyle = 'rgba(150,150,200,0.5)';
        ctx.lineWidth = 1;
        roundRect(backBx, backBy, backBtnW, backBtnH, 6);
        ctx.fill(); ctx.stroke();
        fillText("â† ë’¤ë¡œ", backBx + backBtnW/2, backBy + backBtnH/2 + 5, [180,180,220], '12px "Malgun Gothic", sans-serif', 'center');

        if (!this._isMobile) {
            fillText("[ â†‘â†“ ] ì„ íƒ  [ â†â†’ ] ê°’ ì¡°ì ˆ  [ Space ] ì‹œìž‘  [ ESC ] ë’¤ë¡œ", WIDTH/2, startY + gap * 3 + 30, [120,120,150], '12px "Malgun Gothic", sans-serif', 'center');
        }
    }

    _draw_round_clear() {
        this._draw_bg();
        ctx.fillStyle = 'rgba(0,0,50,0.55)';
        ctx.fillRect(0,0,WIDTH,HEIGHT);

        if (this.round_clear_timer % 8 === 0) {
            for (let i=0;i<3;i++) {
                this.particles.push(new Particle(
                    randUniform(50,WIDTH-50), randUniform(200,500),
                    randUniform(-2,2), randUniform(-3,-1),
                    randChoice([GOLD_C,PUFFER_Y,JELLY_P,CORAL_C,GLOW_C]),
                    randInt(20,40), randInt(2,5)));
            }
        }
        for (const p of this.particles) { p.update(); p.draw(); }

        const y_off = Math.sin(this.t*0.08)*5;
        const rcAnte = this._get_ante();
        const rcStage = this._get_stage();
        fillText(`ì•¤í‹° ${rcAnte} - ${rcStage}/3 í´ë¦¬ì–´!`, WIDTH/2, 260+y_off, [180,200,230], '16px "Malgun Gothic", sans-serif', 'center');
        fillText(`ë¼ìš´ë“œ ${this.round_num} í´ë¦¬ì–´!`, WIDTH/2, 300+y_off, GOLD_C, '36px "Malgun Gothic", sans-serif', 'center');
        if (this.boss_gold_earned > 0) {
            fillText(`ðŸ—‘ï¸ ë³´ìŠ¤ ì²˜ì¹˜! +${this.boss_gold_earned}G`, WIDTH/2, 340, [255,200,80], 'bold 18px "Malgun Gothic", sans-serif', 'center');
        }
        fillText(`ë¼ìš´ë“œ ì ìˆ˜: ${this.round_score.toLocaleString()}`, WIDTH/2, 370, WHITE, '18px "Malgun Gothic", sans-serif', 'center');
        fillText(`íšë“ ê³¨ë“œ: +${this.gold_earned}G`, WIDTH/2, 410, GOLD_C, '24px "Malgun Gothic", sans-serif', 'center');
        let detailY = 432;
        const details = [];
        details.push(`ê¸°ë³¸ ${GOLD_PER_ROUND}G`);
        if (this.bumper_gold_earned > 0) details.push(`ë²”í¼ +${this.bumper_gold_earned}G`);
        if (this.boss_gold_earned > 0) details.push(`ë³´ìŠ¤ +${this.boss_gold_earned}G`);
        if (this.ball_bonus_gold > 0) details.push(`ë‚¨ì€ ê³µ +${this.ball_bonus_gold}G`);
        if (details.length > 1) {
            fillText(`(${details.join(' / ')})`, WIDTH/2, detailY, [200,220,150], '13px "Malgun Gothic", sans-serif', 'center');
            detailY += 22;
        }
        fillText(`ì´ ì ìˆ˜: ${this.score.toLocaleString()}`, WIDTH/2, detailY + 10, [150,180,220], '14px "Malgun Gothic", sans-serif', 'center');

        if (Math.floor(this.t/30)%2) {
            fillText("Spaceë¡œ ê±´ë„ˆë›°ê¸°", WIDTH/2, 540, [120,140,180], '14px "Malgun Gothic", sans-serif', 'center');
        }
    }

    _draw_shop() {
        fillRect(0, 0, WIDTH, HEIGHT, SHOP_BG);

        // Wave deco
        for (let i=0; i<3; i++) {
            const c = lerp_col(SHOP_PANEL, SHOP_BG, i/3);
            ctx.fillStyle = rgb(c);
            ctx.beginPath(); ctx.moveTo(0, 0);
            for (let x=0; x<=WIDTH; x+=5) {
                const yy = 55 + i*3 + Math.sin(x*0.02+this.t*0.03+i)*4;
                ctx.lineTo(x, yy);
            }
            ctx.lineTo(WIDTH, 0); ctx.closePath(); ctx.fill();
        }

        fillText("ìƒ    ì ", WIDTH/2, 38, WHITE, '32px "Malgun Gothic", sans-serif', 'center');

        const next_target = this._get_round_target(this.round_num+1);
        const shopAnte = this._get_ante();
        const shopStage = this._get_stage();
        const nextIsBoss = this._is_boss_round(this.round_num + 1);
        fillText(`ì•¤í‹° ${shopAnte} (${shopStage}/3)  |  ë‹¤ìŒ: ${next_target.toLocaleString()}${nextIsBoss ? ' ðŸ—‘ï¸BOSS' : ''}`, WIDTH/2, 60, nextIsBoss ? [255,180,80] : SKY_SEA, '13px "Malgun Gothic", sans-serif', 'center');

        fillText(`ðŸ’° ${this.gold}G`, 40, 82, GOLD_C, 'bold 18px "Malgun Gothic", sans-serif', 'left');
        fillText(`â¤ï¸ ${this.lives}`, WIDTH-40, 82, PEARL, '14px "Malgun Gothic", sans-serif', 'right');

        // === TAB BAR ===
        const tabNames = ['ê°•í™” ë½‘ê¸°', 'ì†Œëª¨í’ˆ ë½‘ê¸°', 'ê³µ ë½‘ê¸°', 'ìœ ë¬¼ ë½‘ê¸°'];
        const tabY = 95;
        const tabH = 28;
        const tabW = (WIDTH - 40) / 4;
        for (let ti = 0; ti < 4; ti++) {
            const tx = 20 + ti * tabW;
            const isActive = (this.shop_tab === ti);
            ctx.fillStyle = isActive ? 'rgba(80,140,255,0.35)' : 'rgba(30,40,60,0.6)';
            ctx.strokeStyle = isActive ? 'rgba(120,180,255,0.9)' : 'rgba(60,80,120,0.4)';
            ctx.lineWidth = isActive ? 2 : 1;
            roundRect(tx, tabY, tabW - 4, tabH, 6);
            ctx.fill(); ctx.stroke();
            fillText(tabNames[ti], tx + (tabW-4)/2, tabY + tabH/2 + 5, isActive ? WHITE : [140,150,180], `${isActive?'bold ':''}12px "Malgun Gothic", sans-serif`, 'center');
        }

        const content_y = tabY + tabH + 10;

        // === TAB 0: UPGRADE DRAW ===
        if (this.shop_tab === 0) {
            // Show current upgrade levels summary
            const summY = content_y + 2;
            fillText('ë³´ìœ  ê°•í™”', WIDTH/2, summY, [140,170,210], '13px "Malgun Gothic", sans-serif', 'center');
            const rowH = 20;
            for (let i = 0; i < SHOP_ITEMS.length; i++) {
                const item = SHOP_ITEMS[i];
                const lv = this.upgrades[item.id];
                const iy = summY + 12 + i * rowH;
                fillText(`${item.icon} ${item.name}`, 44, iy, WHITE, '13px "Malgun Gothic", sans-serif', 'left');
                // Level dots
                for (let l = 0; l < item.max_lv; l++) {
                    const lx2 = WIDTH - 60 + l * 14;
                    if (l < lv) fillCircle(lx2, iy - 4, 4, GOLD_C);
                    else { fillCircle(lx2, iy - 4, 4, [50,60,80]); strokeCircle(lx2, iy - 4, 4, [80,100,140], 1); }
                }
            }

            // Draw button
            const btnY = summY + 12 + SHOP_ITEMS.length * rowH + 16;
            const allMaxed = SHOP_ITEMS.every(item => this.upgrades[item.id] >= item.max_lv);
            const upgCost = this._get_upgrade_cost();
            const canDraw = !allMaxed && this.gold >= upgCost;
            const btnBg = allMaxed ? [25,55,40] : (canDraw ? [40,70,140] : SHOP_PANEL);
            const btnBorder = allMaxed ? [60,120,60] : (canDraw ? [80,140,255] : [60,80,120]);

            fillRoundRect(40, btnY, WIDTH-80, 48, 10, btnBg);
            strokeRoundRect(40, btnY, WIDTH-80, 48, 10, btnBorder, 2);
            if (allMaxed) {
                fillText('ðŸŽ‰ ëª¨ë“  ê°•í™” ì™„ë£Œ!', WIDTH/2, btnY+28, [100,220,100], 'bold 18px "Malgun Gothic", sans-serif', 'center');
            } else {
                fillText(`ðŸŽ² ê°•í™” ë½‘ê¸°  (${upgCost}G)`, WIDTH/2, btnY+22, canDraw ? WHITE : [120,120,140], 'bold 18px "Malgun Gothic", sans-serif', 'center');
                fillText('2ê°œ ì¤‘ 1ê°œ ì„ íƒ', WIDTH/2, btnY+40, [140,160,200], '11px "Malgun Gothic", sans-serif', 'center');
            }

            // Available upgrades list
            const listY = btnY + 64;
            fillText('ë“±ìž¥ ê°€ëŠ¥í•œ ê°•í™”', WIDTH/2, listY, [100,130,170], '12px "Malgun Gothic", sans-serif', 'center');
            let ly = listY + 16;
            for (const item of SHOP_ITEMS) {
                const lv = this.upgrades[item.id];
                if (lv >= item.max_lv) {
                    fillText(`${item.icon} ${item.name}  âœ… MAX`, WIDTH/2, ly, [60,120,60], '12px "Malgun Gothic", sans-serif', 'center');
                } else {
                    fillText(`${item.icon} ${item.name}  (Lv.${lv}) â€” ${item.desc}`, WIDTH/2, ly, [130,150,180], '12px "Malgun Gothic", sans-serif', 'center');
                }
                ly += 18;
            }

            // === UPGRADE CHOICE OVERLAY ===
            if (this.upgrade_choices) {
                // Dark overlay
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                fillText('ê°•í™”ë¥¼ ì„ íƒí•˜ì„¸ìš”!', WIDTH/2, 100, GOLD_C, 'bold 22px "Malgun Gothic", sans-serif', 'center');

                const cardW = 150, cardH = 200, gap = 20;
                const totalW = this.upgrade_choices.length * cardW + (this.upgrade_choices.length - 1) * gap;
                const startX = WIDTH/2 - totalW/2;

                for (let ci = 0; ci < this.upgrade_choices.length; ci++) {
                    const ch = this.upgrade_choices[ci];
                    const cx = startX + ci * (cardW + gap);
                    const cy = 130;
                    const isPick = (ci === this.upgrade_pick);
                    const lv = this.upgrades[ch.id];
                    const newLv = lv + 1;

                    // Card bg
                    const cbg = isPick ? [50,80,160] : [30,40,65];
                    const cborder = isPick ? [120,180,255] : [60,80,120];
                    fillRoundRect(cx, cy, cardW, cardH, 12, cbg);
                    strokeRoundRect(cx, cy, cardW, cardH, 12, cborder, isPick ? 3 : 1);

                    // Glow for selected
                    if (isPick) {
                        ctx.save();
                        ctx.shadowColor = 'rgba(100,180,255,0.6)';
                        ctx.shadowBlur = 20;
                        fillRoundRect(cx, cy, cardW, cardH, 12, cbg);
                        ctx.restore();
                    }

                    // Icon
                    fillText(ch.icon, cx + cardW/2, cy + 50, WHITE, '40px "Malgun Gothic", sans-serif', 'center');
                    // Name
                    fillText(ch.name, cx + cardW/2, cy + 80, WHITE, 'bold 16px "Malgun Gothic", sans-serif', 'center');
                    // Level change
                    fillText(`Lv.${lv} â†’ Lv.${newLv}`, cx + cardW/2, cy + 105, GOLD_C, 'bold 14px "Malgun Gothic", sans-serif', 'center');
                    // Description
                    fillText(ch.desc, cx + cardW/2, cy + 130, [180,200,230], '12px "Malgun Gothic", sans-serif', 'center');

                    // Level dots
                    const dotStartX = cx + cardW/2 - (ch.max_lv * 14)/2;
                    for (let l = 0; l < ch.max_lv; l++) {
                        const dx = dotStartX + l * 14 + 7;
                        const dy = cy + 155;
                        if (l < newLv) fillCircle(dx, dy, 5, GOLD_C);
                        else { fillCircle(dx, dy, 5, [50,60,80]); strokeCircle(dx, dy, 5, [80,100,140], 1); }
                    }

                    // Selection indicator
                    if (isPick) {
                        fillText('â–²', cx + cardW/2, cy + cardH + 16, GOLD_C, 'bold 16px "Malgun Gothic", sans-serif', 'center');
                    }
                }

                // Hints
                const isMobile = ('ontouchstart' in window);
                if (!isMobile) {
                    fillText('â† â†’ ì„ íƒ  |  Space í™•ì •', WIDTH/2, 360, [120,140,170], '12px "Malgun Gothic", sans-serif', 'center');
                } else {
                    fillText('ì¹´ë“œë¥¼ í„°ì¹˜í•˜ì—¬ ì„ íƒ', WIDTH/2, 360, [120,140,170], '14px "Malgun Gothic", sans-serif', 'center');
                }
            }

        }

        // === TAB 1: CONSUMABLE DRAW ===
        else if (this.shop_tab === 1) {
            // Inventory display
            fillText(`ì†Œëª¨í’ˆ ë°•ìŠ¤: ${this.consumable_inv.length}/${this.consumable_max}`, WIDTH/2, content_y + 6, this.consumable_inv.length >= this.consumable_max ? [255,100,100] : [140,170,210], '13px "Malgun Gothic", sans-serif', 'center');

            // Current inventory cards
            const invY = content_y + 20;
            const invCardW = 100, invCardH = 70, invGap = 12;
            const invTotalW = this.consumable_max * (invCardW + invGap) - invGap;
            const invStartX = WIDTH/2 - invTotalW/2;
            for (let i = 0; i < this.consumable_max; i++) {
                const ix = invStartX + i * (invCardW + invGap);
                if (i < this.consumable_inv.length) {
                    const cons = CONSUMABLES.find(c => c.id === this.consumable_inv[i]);
                    if (cons) {
                        ctx.fillStyle = `rgba(${cons.color[0]},${cons.color[1]},${cons.color[2]},0.25)`;
                        ctx.strokeStyle = `rgba(${cons.color[0]},${cons.color[1]},${cons.color[2]},0.7)`;
                        ctx.lineWidth = 2;
                        roundRect(ix, invY, invCardW, invCardH, 8);
                        ctx.fill(); ctx.stroke();
                        fillText(cons.icon, ix + invCardW/2, invY + 30, WHITE, '22px "Malgun Gothic", sans-serif', 'center');
                        fillText(cons.name, ix + invCardW/2, invY + 55, WHITE, '12px "Malgun Gothic", sans-serif', 'center');
                    }
                } else {
                    ctx.fillStyle = 'rgba(30,40,60,0.3)';
                    ctx.strokeStyle = 'rgba(60,70,90,0.3)';
                    ctx.lineWidth = 1;
                    roundRect(ix, invY, invCardW, invCardH, 8);
                    ctx.fill(); ctx.stroke();
                    fillText("ë¹ˆ ì¹¸", ix + invCardW/2, invY + 40, [80,90,110], '12px "Malgun Gothic", sans-serif', 'center');
                }
            }

            // Draw button
            const drawY = invY + invCardH + 24;
            const drawH = 60;
            const canDraw = this.gold >= CONSUMABLE_DRAW_COST && this.consumable_inv.length < this.consumable_max;
            const drawSel = (this.shop_cursor === 0);

            let dbg, dbd;
            if (drawSel) { dbg = SHOP_HIGHLIGHT; dbd = [100,180,255]; }
            else { dbg = [30,40,70]; dbd = [50,80,140]; }
            fillRoundRect(24, drawY, WIDTH-48, drawH, 8, dbg);
            strokeRoundRect(24, drawY, WIDTH-48, drawH, 8, dbd, 2);

            if (drawSel) {
                const ax = 10, ay = drawY + drawH/2;
                const pulse = Math.sin(this.t*0.1)*3;
                ctx.fillStyle = rgb(GOLD_C);
                ctx.beginPath();
                ctx.moveTo(ax+pulse, ay); ctx.lineTo(ax-6+pulse, ay-6); ctx.lineTo(ax-6+pulse, ay+6);
                ctx.closePath(); ctx.fill();
            }

            const dtc = drawSel ? [20,20,30] : WHITE;
            const dcc = drawSel ? (canDraw ? [20,20,30] : [150,50,50]) : (canDraw ? GOLD_C : [120,80,80]);
            fillText("ðŸŽ² ì†Œëª¨í’ˆ ë½‘ê¸°", 44, drawY + 24, dtc, 'bold 20px "Malgun Gothic", sans-serif', 'left');
            fillText("ëžœë¤ ì†Œëª¨í’ˆ 1ê°œë¥¼ ë½‘ìŠµë‹ˆë‹¤", 44, drawY + 46, drawSel ? [50,50,60] : [130,160,200], '13px "Malgun Gothic", sans-serif', 'left');
            fillText(`${CONSUMABLE_DRAW_COST}G`, WIDTH-68, drawY + 24, dcc, 'bold 20px "Malgun Gothic", sans-serif', 'right');

            if (this.consumable_inv.length >= this.consumable_max) {
                fillText("âš  ë°•ìŠ¤ê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!", WIDTH/2, drawY + drawH + 24, [255,100,100], '14px "Malgun Gothic", sans-serif', 'center');
            }

            // Consumable types reference
            const refY = drawY + drawH + 50;
            fillText("ë½‘ì„ ìˆ˜ ìžˆëŠ” ì†Œëª¨í’ˆ", 44, refY, [140,170,210], '13px "Malgun Gothic", sans-serif', 'left');
            for (let ci = 0; ci < CONSUMABLES.length; ci++) {
                const cons = CONSUMABLES[ci];
                const ry = refY + 20 + ci * 28;
                fillText(cons.icon, 50, ry + 10, WHITE, '16px "Malgun Gothic", sans-serif', 'left');
                fillText(cons.name, 72, ry + 10, WHITE, '13px "Malgun Gothic", sans-serif', 'left');
                fillText(cons.desc, 170, ry + 10, [130,160,200], '12px "Malgun Gothic", sans-serif', 'left');
            }

            // Draw result popup
            if (this.consumable_draw_timer > 0 && this.consumable_draw_result) {
                const fade = Math.min(1, this.consumable_draw_timer / 20);
                ctx.fillStyle = `rgba(0,0,30,${(0.7*fade).toFixed(2)})`;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                const cr = this.consumable_draw_result;
                const popY = HEIGHT/2 - 60;

                // Glow
                ctx.fillStyle = `rgba(${cr.color[0]},${cr.color[1]},${cr.color[2]},${(0.2*fade).toFixed(2)})`;
                ctx.beginPath(); ctx.arc(WIDTH/2, popY, 80, 0, Math.PI*2); ctx.fill();

                fillText(cr.icon, WIDTH/2, popY, WHITE, '48px "Malgun Gothic", sans-serif', 'center');
                fillText(cr.name, WIDTH/2, popY + 45, cr.color, 'bold 24px "Malgun Gothic", sans-serif', 'center');
                fillText(cr.desc, WIDTH/2, popY + 72, [180,200,230], '14px "Malgun Gothic", sans-serif', 'center');
                fillText("ì†Œëª¨í’ˆ ë°•ìŠ¤ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!", WIDTH/2, popY + 100, [150,170,210], '13px "Malgun Gothic", sans-serif', 'center');
            }
        }

        // === TAB 2: GACHA (3 slots) ===
        else if (this.shop_tab === 2) {
            const can_gacha = this.gold >= GACHA_COST;
            const slotLabels = ['1ë²ˆì§¸ ê³µ', '2ë²ˆì§¸ ê³µ', '3ë²ˆì§¸ ê³µ'];

            // 3 slot cards
            const slotH = 72;
            const slotGap = 8;
            let slotY = content_y;
            for (let si = 0; si < 3; si++) {
                const sel = (this.shop_cursor === si);
                const sbt = this.ball_slots[si];
                let sbg, sbd;
                if (sel) { sbg = SHOP_HIGHLIGHT; sbd = [100,180,255]; }
                else { sbg = [20,30,50]; sbd = [40,60,100]; }
                fillRoundRect(24, slotY, WIDTH-48, slotH, 8, sbg);
                strokeRoundRect(24, slotY, WIDTH-48, slotH, 8, sbd, sel ? 2 : 1);

                // Slot label
                const labelCol = sel ? [20,20,30] : [140,170,210];
                fillText(slotLabels[si], 44, slotY+16, labelCol, 'bold 13px "Malgun Gothic", sans-serif', 'left');

                // Cost
                const costCol = sel ? [20,20,30] : (can_gacha ? GOLD_C : [120,80,80]);
                fillText(`${GACHA_COST}G`, WIDTH-44, slotY+16, costCol, 'bold 13px "Malgun Gothic", sans-serif', 'right');

                // Ball info
                if (sbt) {
                    fillCircle(52, slotY+46, 12, sbt.color);
                    fillCircle(49, slotY+43, 4, WHITE);
                    strokeCircle(52, slotY+46, 12, lerp_col(sbt.color, BLACK, 0.3), 2);
                    const rc = RARITY_COLORS[sbt.rarity];
                    fillText(`[${sbt.rarity_name}] ${sbt.name}`, 72, slotY+42, rc, 'bold 14px "Malgun Gothic", sans-serif', 'left');
                    fillText(sbt.desc, 72, slotY+60, sel ? [40,50,70] : [150,180,220], '12px "Malgun Gothic", sans-serif', 'left');
                } else {
                    fillCircle(52, slotY+46, 12, PEARL);
                    fillCircle(49, slotY+43, 4, WHITE);
                    fillText("ê¸°ë³¸ ê³µ", 72, slotY+42, sel ? [40,50,70] : [180,200,220], '14px "Malgun Gothic", sans-serif', 'left');
                    fillText("ë½‘ê¸°ë¡œ ê³µì„ ìž¥ì°©í•˜ì„¸ìš”", 72, slotY+60, sel ? [60,60,80] : [130,160,200], '12px "Malgun Gothic", sans-serif', 'left');
                }

                // Selection arrow
                if (sel) fillText("â–¶", 32, slotY+46, [20,20,30], 'bold 14px "Malgun Gothic", sans-serif', 'left');

                slotY += slotH + slotGap;
            }

            // Draw instruction
            fillText("[ â†‘â†“ ] ìŠ¬ë¡¯ ì„ íƒ  [ Space ] ë½‘ê¸°", WIDTH/2, slotY+8, [100,130,180], '12px "Malgun Gothic", sans-serif', 'center');

            // Ball types reference
            const refY = slotY + 28;
            fillText("ê³µ ì¢…ë¥˜ ì•ˆë‚´", 44, refY, [140,170,210], '13px "Malgun Gothic", sans-serif', 'left');
            const BALL_TYPES_REF = typeof BALL_TYPES !== 'undefined' ? BALL_TYPES : [];
            for (let bi = 0; bi < BALL_TYPES_REF.length && bi < 9; bi++) {
                const bt = BALL_TYPES_REF[bi];
                const bx = 40 + (bi % 2) * (WIDTH/2 - 30);
                const by = refY + 12 + Math.floor(bi/2) * 28;
                fillCircle(bx, by+6, 6, bt.color);
                fillCircle(bx-1, by+5, 2, WHITE);
                const rc = RARITY_COLORS[bt.rarity];
                fillText(`${bt.name}`, bx+14, by+10, rc, '12px "Malgun Gothic", sans-serif', 'left');
            }
        }

        // === TAB 3: RELIC DRAW ===
        else if (this.shop_tab === 3) {
            const relic_sel = (this.shop_cursor === 0);
            const available = RELICS.filter(r => !this.relics[r.id]);
            const allOwned = available.length === 0;
            const anteLimitReached = this.relic_bought_ante >= 1;
            const can_relic = !allOwned && !anteLimitReached && this.gold >= RELIC_COST;

            // Owned relics display
            const ownedRelics = RELICS.filter(r => this.relics[r.id]);
            fillText(`ë³´ìœ  ìœ ë¬¼: ${ownedRelics.length}/${RELICS.length}`, WIDTH/2, content_y + 6, [140,170,210], '13px "Malgun Gothic", sans-serif', 'center');

            const listY = content_y + 22;
            if (ownedRelics.length > 0) {
                for (let ri = 0; ri < ownedRelics.length; ri++) {
                    const rl = ownedRelics[ri];
                    const rx = 40 + (ri % 2) * (WIDTH/2 - 20);
                    const ry = listY + Math.floor(ri/2) * 32;
                    fillText(`${rl.icon} ${rl.name}`, rx, ry + 10, [200,220,255], 'bold 13px "Malgun Gothic", sans-serif', 'left');
                    fillText(rl.desc, rx + 2, ry + 26, [130,160,200], '11px "Malgun Gothic", sans-serif', 'left');
                }
            } else {
                fillText("ì•„ì§ ìœ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤", WIDTH/2, listY + 16, [100,120,160], '13px "Malgun Gothic", sans-serif', 'center');
            }

            // Draw button
            const ownedRows = Math.max(1, Math.ceil(ownedRelics.length / 2));
            const btnY = listY + ownedRows * 32 + 16;
            const btnH = 60;
            let rbg, rbd;
            if (relic_sel) { rbg = SHOP_HIGHLIGHT; rbd = [100,180,255]; }
            else { rbg = [30,40,70]; rbd = [50,80,140]; }
            fillRoundRect(24, btnY, WIDTH-48, btnH, 8, rbg);
            strokeRoundRect(24, btnY, WIDTH-48, btnH, 8, rbd, 2);

            if (allOwned) {
                fillText('ðŸŽ‰ ëª¨ë“  ìœ ë¬¼ ìˆ˜ì§‘ ì™„ë£Œ!', WIDTH/2, btnY+34, [100,220,100], 'bold 18px "Malgun Gothic", sans-serif', 'center');
            } else if (anteLimitReached) {
                fillText('ì´ë²ˆ ì•¤í‹°ì—ì„œ ì´ë¯¸ êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤', WIDTH/2, btnY+28, [200,150,80], 'bold 16px "Malgun Gothic", sans-serif', 'center');
                fillText('ë‹¤ìŒ ì•¤í‹°ì—ì„œ ë‹¤ì‹œ êµ¬ë§¤í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤', WIDTH/2, btnY+48, [140,120,80], '12px "Malgun Gothic", sans-serif', 'center');
            } else {
                const r_txt_col = relic_sel ? [20,20,30] : WHITE;
                const r_cost_col = relic_sel ? [20,20,30] : (can_relic ? GOLD_C : [120,80,80]);
                fillText("ðŸº ìœ ë¬¼ ë½‘ê¸°", 44, btnY+24, r_txt_col, 'bold 20px "Malgun Gothic", sans-serif', 'left');
                fillText(`ëžœë¤ ì˜êµ¬ ëŠ¥ë ¥ íšë“ (${available.length}ì¢… ë‚¨ìŒ)`, 44, btnY+46, relic_sel ? [50,50,60] : [130,160,200], '13px "Malgun Gothic", sans-serif', 'left');
                fillText(`${RELIC_COST}G`, WIDTH-68, btnY+24, r_cost_col, 'bold 20px "Malgun Gothic", sans-serif', 'right');
            }

            // All relics reference
            const refY = btnY + btnH + 20;
            fillText("ìœ ë¬¼ ë„ê°", 44, refY, [140,170,210], '13px "Malgun Gothic", sans-serif', 'left');
            for (let ri = 0; ri < RELICS.length; ri++) {
                const rl = RELICS[ri];
                const rx = 40 + (ri % 2) * (WIDTH/2 - 20);
                const ry = refY + 14 + Math.floor(ri/2) * 24;
                const owned = !!this.relics[rl.id];
                fillText(`${rl.icon} ${rl.name}`, rx, ry+10, owned ? [200,220,255] : [80,90,120], `${owned?'bold ':''}12px "Malgun Gothic", sans-serif`, 'left');
            }
        }

        // Key hints (non-mobile)
        if (!this._isMobile) {
            fillText("[ â†â†’ ] íƒ­  [ Space ] ë½‘ê¸°  [ Enter ê¾¹ ] ë‹¤ìŒ", WIDTH/2, HEIGHT-18, [100,130,180], '13px "Malgun Gothic", sans-serif', 'center');
        }

        // === RELIC CHOICE OVERLAY (rendered over any tab) ===
        if (this.relic_choices) {
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            fillText('ìœ ë¬¼ì„ ì„ íƒí•˜ì„¸ìš”!', WIDTH/2, 100, [100,180,255], 'bold 22px "Malgun Gothic", sans-serif', 'center');

            const rcW = 150, rcH = 180, rcGap = 20;
            const rcTotalW = this.relic_choices.length * rcW + (this.relic_choices.length - 1) * rcGap;
            const rcStartX = WIDTH/2 - rcTotalW/2;

            for (let ci = 0; ci < this.relic_choices.length; ci++) {
                const rl = this.relic_choices[ci];
                const cx = rcStartX + ci * (rcW + rcGap);
                const cy = 130;
                const isPick = (ci === this.relic_pick);

                const cbg = isPick ? [40,60,120] : [25,35,60];
                const cborder = isPick ? [100,180,255] : [50,70,110];
                fillRoundRect(cx, cy, rcW, rcH, 12, cbg);
                strokeRoundRect(cx, cy, rcW, rcH, 12, cborder, isPick ? 3 : 1);

                if (isPick) {
                    ctx.save();
                    ctx.shadowColor = 'rgba(100,180,255,0.6)';
                    ctx.shadowBlur = 20;
                    fillRoundRect(cx, cy, rcW, rcH, 12, cbg);
                    ctx.restore();
                }

                fillText(rl.icon, cx + rcW/2, cy + 50, WHITE, '40px "Malgun Gothic", sans-serif', 'center');
                fillText(rl.name, cx + rcW/2, cy + 85, [220,240,255], 'bold 16px "Malgun Gothic", sans-serif', 'center');
                fillText(rl.desc, cx + rcW/2, cy + 115, [150,180,220], '12px "Malgun Gothic", sans-serif', 'center');

                if (isPick) {
                    fillText('â–²', cx + rcW/2, cy + rcH + 16, [100,180,255], 'bold 16px "Malgun Gothic", sans-serif', 'center');
                }
            }

            const isMobileRC = ('ontouchstart' in window);
            if (!isMobileRC) {
                fillText('â† â†’ ì„ íƒ  |  Space í™•ì •', WIDTH/2, 340, [120,140,170], '12px "Malgun Gothic", sans-serif', 'center');
            } else {
                fillText('ì¹´ë“œë¥¼ í„°ì¹˜í•˜ì—¬ ì„ íƒ', WIDTH/2, 340, [120,140,170], '14px "Malgun Gothic", sans-serif', 'center');
            }
        }

        // Relic result popup
        if (this.relic_result_timer > 0) {
            const fade = Math.min(1, this.relic_result_timer / 30);
            ctx.fillStyle = `rgba(0,0,30,${(0.63*fade).toFixed(2)})`;
            ctx.fillRect(0,0,WIDTH,HEIGHT);

            const rl = this.relic_result;
            const popY = HEIGHT/2 - 60;
            fillRoundRect(60, popY, WIDTH-120, 120, 12, [20,30,60]);
            strokeRoundRect(60, popY, WIDTH-120, 120, 12, [100,180,255], 2);
            fillText("ìœ ë¬¼ íšë“!", WIDTH/2, popY + 20, [100,180,255], 'bold 16px "Malgun Gothic", sans-serif', 'center');
            fillText(`${rl.icon}`, WIDTH/2, popY + 55, WHITE, '36px "Malgun Gothic", sans-serif', 'center');
            fillText(rl.name, WIDTH/2, popY + 80, [220,240,255], 'bold 20px "Malgun Gothic", sans-serif', 'center');
            fillText(rl.desc, WIDTH/2, popY + 102, [150,180,220], '14px "Malgun Gothic", sans-serif', 'center');
        }

        // Gacha result popup
        if (this.gacha_result_timer > 0) {
            const fade = Math.min(1, this.gacha_result_timer / 30);
            ctx.fillStyle = `rgba(0,0,30,${(0.63*fade).toFixed(2)})`;
            ctx.fillRect(0,0,WIDTH,HEIGHT);

            const bt = this.gacha_result;
            const rarity = bt.rarity;
            const rc = RARITY_COLORS[rarity];
            const cx = WIDTH/2, cy = HEIGHT/2 - 30;

            if (rarity >= 1) {
                const num = rarity*6+4;
                for (let i2=0;i2<num;i2++) {
                    const ang = this.t*0.06+i2*Math.PI*2/num;
                    const dist = 50+Math.sin(this.t*0.1+i2)*12;
                    const sr = 2+Math.sin(this.t*0.2+i2*0.7);
                    fillCircle(cx+dist*Math.cos(ang), cy+dist*Math.sin(ang), Math.max(1,sr), rc);
                }
            }

            const glow_r = 55+Math.sin(this.t*0.15)*8;
            ctx.fillStyle = rgba(rc, 0.18*fade);
            ctx.beginPath(); ctx.arc(cx, cy, glow_r*2, 0, Math.PI*2); ctx.fill();

            fillCircle(cx, cy, 24, bt.color);
            fillCircle(cx-6, cy-6, 7, WHITE);
            strokeCircle(cx, cy, 24, rc, 2);

            fillText(`[ ${bt.rarity_name} ]`, cx, cy-42, rc, '14px "Malgun Gothic", sans-serif', 'center');
            fillText(bt.name, cx, cy+55, WHITE, '26px "Malgun Gothic", sans-serif', 'center');
            fillText(bt.desc, cx, cy+82, [180,200,230], '14px "Malgun Gothic", sans-serif', 'center');
        }
    }

    _draw_gameover() {
        this._draw_bg();
        if (this._testMode) {
            fillText("[ í…ŒìŠ¤íŠ¸ ëª¨ë“œ ]", WIDTH/2, 230, BALATRO_ORANGE, '16px "Malgun Gothic", sans-serif', 'center');
        }
        fillText("ê²Œìž„ ì˜¤ë²„", WIDTH/2, 270, [255,100,100], '42px "Malgun Gothic", sans-serif', 'center');
        const goAnte = this._get_ante();
        const goStage = this._get_stage();
        fillText(`ì•¤í‹° ${goAnte} - ${goStage}/3  (ë¼ìš´ë“œ ${this.round_num})`, WIDTH/2, 330, GOLD_C, '22px "Malgun Gothic", sans-serif', 'center');
        fillText(`ìµœì¢… ì ìˆ˜: ${this.score.toLocaleString()}`, WIDTH/2, 380, WHITE, '20px "Malgun Gothic", sans-serif', 'center');

        if (!this._testMode && this.score >= this.high_score && this.score > 0) {
            fillText("ìƒˆë¡œìš´ ìµœê³  ê¸°ë¡!", WIDTH/2, 420, GOLD_C, '20px "Malgun Gothic", sans-serif', 'center');
        }

        let upgrade_y = 470;
        const has_upgrades = Object.values(this.upgrades).some(v => v > 0);
        if (has_upgrades) {
            fillText("ì´ë²ˆ ëŸ° ì—…ê·¸ë ˆì´ë“œ:", WIDTH/2, upgrade_y, [150,180,220], '14px "Malgun Gothic", sans-serif', 'center');
            upgrade_y += 22;
            for (const item of SHOP_ITEMS) {
                const lv = this.upgrades[item.id];
                if (lv > 0) {
                    fillText(`${item.name} Lv.${lv}`, WIDTH/2, upgrade_y, SKY_SEA, '14px "Malgun Gothic", sans-serif', 'center');
                    upgrade_y += 18;
                }
            }
        }

        if (Math.floor(this.t/40)%2) {
            fillText("ìŠ¤íŽ˜ì´ìŠ¤ í‚¤ë¡œ ë©”ë‰´ë¡œ", WIDTH/2, HEIGHT-80, WHITE, '20px "Malgun Gothic", sans-serif', 'center');
        }
    }

    _draw_victory() {
        this._draw_bg();

        // Celebration particles
        if (this.t % 5 === 0) {
            for (let i = 0; i < 5; i++) {
                this.particles.push(new Particle(
                    randUniform(30, WIDTH - 30), randUniform(100, 400),
                    randUniform(-3, 3), randUniform(-4, -1),
                    randChoice([GOLD_C, [255,220,100], [100,255,200], [100,180,255], [255,150,200]]),
                    randInt(30, 60), randInt(2, 6)));
            }
        }
        for (const p of this.particles) { p.update(); p.draw(); }

        // Gold shimmer overlay
        ctx.fillStyle = 'rgba(255,220,80,0.03)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        const y_off = Math.sin(this.t * 0.06) * 5;

        fillText("ðŸŽ‰", WIDTH/2, 180 + y_off, WHITE, '60px "Malgun Gothic", sans-serif', 'center');
        fillText("ê²Œìž„ í´ë¦¬ì–´!", WIDTH/2, 260 + y_off, GOLD_C, '42px "Malgun Gothic", sans-serif', 'center');
        fillText("8ì•¤í‹°ë¥¼ ëª¨ë‘ ëŒíŒŒí–ˆìŠµë‹ˆë‹¤!", WIDTH/2, 310, [200, 230, 255], '18px "Malgun Gothic", sans-serif', 'center');

        fillText(`ìµœì¢… ì ìˆ˜: ${this.score.toLocaleString()}`, WIDTH/2, 370, WHITE, '22px "Malgun Gothic", sans-serif', 'center');
        fillText(`ë„ë‹¬ ë¼ìš´ë“œ: ${this.round_num}`, WIDTH/2, 405, [180, 200, 230], '16px "Malgun Gothic", sans-serif', 'center');

        if (!this._testMode && this.score > 0) {
            if (this.score >= this.high_score) {
                fillText("ðŸ† ìƒˆë¡œìš´ ìµœê³  ê¸°ë¡!", WIDTH/2, 445, GOLD_C, 'bold 20px "Malgun Gothic", sans-serif', 'center');
            }
        }

        // Upgrades summary
        let uy = 490;
        const has_upgrades = Object.values(this.upgrades).some(v => v > 0);
        if (has_upgrades) {
            fillText("ì´ë²ˆ ëŸ° ì—…ê·¸ë ˆì´ë“œ:", WIDTH/2, uy, [150,180,220], '14px "Malgun Gothic", sans-serif', 'center');
            uy += 20;
            for (const item of SHOP_ITEMS) {
                const lv = this.upgrades[item.id];
                if (lv > 0) {
                    fillText(`${item.icon} ${item.name} Lv.${lv}`, WIDTH/2, uy, SKY_SEA, '13px "Malgun Gothic", sans-serif', 'center');
                    uy += 17;
                }
            }
        }

        if (Math.floor(this.t / 35) % 2) {
            fillText("ìŠ¤íŽ˜ì´ìŠ¤ í‚¤ë¡œ ë©”ë‰´ë¡œ", WIDTH/2, HEIGHT - 80, WHITE, '18px "Malgun Gothic", sans-serif', 'center');
        }
    }

    _draw() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        if (this.state === 'menu') this._draw_menu();
        else if (this.state === 'test_setup') this._draw_test_setup();
        else if (this.state === 'gameover') this._draw_gameover();
        else if (this.state === 'victory') this._draw_victory();
        else if (this.state === 'round_clear') this._draw_round_clear();
        else if (this.state === 'shop') this._draw_shop();
        else if (this.state === 'play') {
            this._draw_bg();
            this._draw_walls();
            for (const sl of this.slings) sl.draw(this.t);
            for (const dt of this.drops) dt.draw(this.t);
            for (const bm of this.bumpers) bm.draw(this.t);
            if (this.boss) this.boss.draw(this.t);
            this.pin.draw(this.t);
            this.spinner.draw(this.t);
            this.lf.draw(); this.rf.draw();
            for (const ball of this.balls) ball.draw(this.t);

            // Magnet zone
            const bt_eff_draw = (this.current_ball_type || {}).effects || {};
            if (bt_eff_draw.magnet) {
                const pulse = (15 + 10*Math.sin(this.t*0.08))/255;
                ctx.fillStyle = rgba([255,60,60], pulse);
                ctx.fillRect(30, 600, TABLE_R-30, HEIGHT-600);
                const cx2 = 250;
                for (let yy=610; yy<HEIGHT-20; yy+=12) {
                    const wave = Math.sin(this.t*0.15+yy*0.03)*8;
                    const alpha2 = Math.min(0.31, (40+(yy-610)*0.3)/255);
                    ctx.fillStyle = rgba([255,100,100], alpha2);
                    ctx.beginPath(); ctx.arc(cx2+wave, yy, 2, 0, Math.PI*2); ctx.fill();
                }
            }

            // Feather particles
            if ((bt_eff_draw.gravity_mult || 1.0) < 0.9) {
                for (let k=0;k<6;k++) {
                    const fx = (this.t*0.4+k*80)%WIDTH;
                    const fy = (this.t*0.2+k*120+Math.sin(this.t*0.03+k)*30)%HEIGHT;
                    ctx.fillStyle = rgba([200,230,255], 0.2);
                    ctx.beginPath(); ctx.arc(fx, fy, 3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = rgba([220,240,255], 0.12);
                    ctx.beginPath(); ctx.arc(fx, fy, 6, 0, Math.PI*2); ctx.fill();
                }
            }

            this.plunger.draw();
            for (const p of this.particles) p.draw();
            for (const p of this.popups) p.draw();
            this.bonus.draw();
            this._draw_ui();
        }

        // CRT Scanlines
        ctx.fillStyle = 'rgba(0,0,0,0.04)';
        for (let y=0; y<HEIGHT; y+=3) {
            ctx.fillRect(0, y, WIDTH, 1);
        }
    }

    // ============================================================
    //  MOBILE TOUCH CONTROLS
    // ============================================================
    _drawTouchControls() {
        if (this.state === 'play' && this._isMobile) {
            // Left flipper zone
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.fillRect(0, HEIGHT*0.5, WIDTH*0.35, HEIGHT*0.5);
            // Right flipper zone
            ctx.fillRect(WIDTH*0.65, HEIGHT*0.5, WIDTH*0.35, HEIGHT*0.5);
            // Plunger zone
            ctx.fillStyle = 'rgba(255,200,40,0.08)';
            ctx.fillRect(WIDTH*0.35, HEIGHT*0.75, WIDTH*0.3, HEIGHT*0.25);

            // Labels
            ctx.globalAlpha = 0.25;
            fillText("L", WIDTH*0.175, HEIGHT*0.55, WHITE, 'bold 28px sans-serif', 'center');
            fillText("R", WIDTH*0.825, HEIGHT*0.55, WHITE, 'bold 28px sans-serif', 'center');
            if (this.ball_in_p) fillText("â–²", WIDTH*0.5, HEIGHT*0.88, BALATRO_GOLD, 'bold 24px sans-serif', 'center');
            ctx.globalAlpha = 1;
        }

        if (this.state === 'shop') {
            // Bottom bar: Buy button + Next round hold button
            const btnH = 50;
            const buyW = WIDTH * 0.45;
            const nrW2 = WIDTH * 0.45;

            // Buy/Draw button
            const buyLabel = this.shop_tab === 0 ? "ê°•í™” ë½‘ê¸°" : (this.shop_tab === 1 ? "ì†Œëª¨í’ˆ ë½‘ê¸°" : (this.shop_tab === 2 ? "ê³µ ë½‘ê¸°" : "ìœ ë¬¼ ë½‘ê¸°"));
            fillRoundRect(10, HEIGHT-btnH-5, buyW, btnH-5, 8, [60,80,40]);
            strokeRoundRect(10, HEIGHT-btnH-5, buyW, btnH-5, 8, [120,180,80], 2);
            fillText(buyLabel, 10+buyW/2, HEIGHT-btnH+22, BALATRO_GOLD, 'bold 18px "Malgun Gothic",sans-serif', 'center');

            // Next round (hold button with progress)
            const nrX = WIDTH-nrW2-10, nrY = HEIGHT-btnH-5, nrH2 = btnH-5;
            const holdProg = this._nextRoundHold / this._nextRoundRequired;
            fillRoundRect(nrX, nrY, nrW2, nrH2, 8, [80,40,40]);
            if (holdProg > 0) {
                const fillH2 = Math.round(nrH2 * holdProg);
                ctx.save();
                roundRect(nrX, nrY, nrW2, nrH2, 8);
                ctx.clip();
                fillRect(nrX, nrY+nrH2-fillH2, nrW2, fillH2, [180,80,80]);
                ctx.restore();
            }
            strokeRoundRect(nrX, nrY, nrW2, nrH2, 8, holdProg > 0 ? [255,120,120] : [180,80,80], 2);
            fillText(holdProg > 0 ? `ê¾¹! ${Math.round(holdProg*100)}%` : "ë‹¤ìŒ ë¼ìš´ë“œ â–¸", nrX+nrW2/2, nrY+nrH2/2+6, WHITE, 'bold 15px "Malgun Gothic",sans-serif', 'center');
        }
    }

    _setupTouch() {
        // Detect mobile
        this._isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        this._activeTouches = {};
        this._plungerTouch = null;

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            this._isMobile = true; // confirmed touch device
            if (!audioCtx) initAudio();
            for (const touch of e.changedTouches) {
                const [tx, ty] = this._touchPos(touch);
                this._activeTouches[touch.identifier] = {x:tx, y:ty, startY:ty};
                this._handleTouchStart(tx, ty, touch.identifier);
            }
        }, {passive:false});

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const [tx, ty] = this._touchPos(touch);
                if (this._activeTouches[touch.identifier]) {
                    this._activeTouches[touch.identifier].x = tx;
                    this._activeTouches[touch.identifier].y = ty;
                }
                this._handleTouchMove(tx, ty, touch.identifier);
            }
        }, {passive:false});

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const [tx, ty] = this._touchPos(touch);
                this._handleTouchEnd(tx, ty, touch.identifier);
                delete this._activeTouches[touch.identifier];
            }
        }, {passive:false});
    }

    _touchPos(touch) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = WIDTH / rect.width;
        const scaleY = HEIGHT / rect.height;
        return [(touch.clientX - rect.left)*scaleX, (touch.clientY - rect.top)*scaleY];
    }

    _handleTouchStart(x, y, id) {
        if (this.state === 'menu') {
            this._onKeyDown('Space');
            return;
        }
        if (this.state === 'gameover' || this.state === 'victory' || this.state === 'round_clear') {
            this._onKeyDown('Space');
            return;
        }
        if (this.state === 'test_setup') {
            // Back button (top-left)
            if (x >= 10 && x <= 70 && y >= 15 && y <= 45) {
                this.state = 'menu';
                return;
            }

            const startY = 300, gap = 70, boxW = 360, boxH = 50;
            const bxStart = WIDTH/2 - boxW/2;
            const btnSize = 36;

            for (let i = 0; i < 3; i++) {
                const iy = startY + i * gap;
                if (y >= iy - boxH/2 && y <= iy + boxH/2) {
                    this._testCursor = i;
                    if (i < 2) {
                        const valCenterX = bxStart + boxW - 90;
                        const minusBx = valCenterX - 70 - btnSize/2;
                        const plusBx = valCenterX + 70 - btnSize/2;
                        // Check minus button
                        if (x >= minusBx && x <= minusBx + btnSize) {
                            this._onKeyDown('ArrowLeft');
                        }
                        // Check plus button
                        else if (x >= plusBx && x <= plusBx + btnSize) {
                            this._onKeyDown('ArrowRight');
                        }
                    } else {
                        this._onKeyDown('Space');
                    }
                    return;
                }
            }
            return;
        }
        if (this.state === 'shop') {
            if (this._stateChangeCooldown > 0) return; // ignore touch during cooldown

            // Upgrade choice overlay touch - must pick one
            if (this.upgrade_choices) {
                const cardW = 150, cardH = 200, gap = 20;
                const totalCW = this.upgrade_choices.length * cardW + (this.upgrade_choices.length - 1) * gap;
                const startCX = WIDTH/2 - totalCW/2;
                const cy = 130;

                for (let ci = 0; ci < this.upgrade_choices.length; ci++) {
                    const cx = startCX + ci * (cardW + gap);
                    if (x >= cx && x <= cx + cardW && y >= cy && y <= cy + cardH) {
                        this.upgrade_pick = ci;
                        this._upgrade_pick_confirm();
                        return;
                    }
                }
                return; // ignore all other touches, must pick a card
            }

            // Relic choice overlay touch - must pick one
            if (this.relic_choices) {
                const rcW = 150, rcH = 180, rcGap = 20;
                const rcTotalCW = this.relic_choices.length * rcW + (this.relic_choices.length - 1) * rcGap;
                const rcStartCX = WIDTH/2 - rcTotalCW/2;
                const rcy = 130;

                for (let ci = 0; ci < this.relic_choices.length; ci++) {
                    const cx = rcStartCX + ci * (rcW + rcGap);
                    if (x >= cx && x <= cx + rcW && y >= rcy && y <= rcy + rcH) {
                        this.relic_pick = ci;
                        this._relic_pick_confirm();
                        return;
                    }
                }
                return; // ignore all other touches, must pick a card
            }

            // Tab bar touch (y: 95 to 123)
            const tabY = 95, tabH = 28, tabW = (WIDTH - 40) / 4;
            if (y >= tabY && y <= tabY + tabH) {
                const ti = Math.floor((x - 20) / tabW);
                if (ti >= 0 && ti < 4 && ti !== this.shop_tab) {
                    this.shop_tab = ti;
                    this.shop_cursor = 0;
                }
                return;
            }

            // Bottom buttons
            const btnH = 50;
            const buyW = WIDTH * 0.45;
            const nrW2 = WIDTH * 0.45;
            // Buy button
            if (x < buyW + 10 && y > HEIGHT - btnH - 5) {
                this._onKeyDown('Space'); return;
            }
            // Next round button (hold to activate)
            if (x > WIDTH - nrW2 - 10 && y > HEIGHT - btnH - 5) {
                this._nextRoundHolding = true;
                this._nextRoundTouchId = id;
                return;
            }

            // Content area touch - select item
            const content_y = tabY + tabH + 10;
            if (y >= content_y && y < HEIGHT - btnH - 10) {
                if (this.shop_tab === 0) {
                    this.shop_cursor = 0; // only 1 item (draw button)
                } else if (this.shop_tab === 1) {
                    this.shop_cursor = 0; // only 1 item (draw button)
                } else if (this.shop_tab === 2) {
                    // 3 slot cards: determine which slot was touched
                    const slotH = 72, slotGap = 8;
                    const relY = y - content_y;
                    const slotIdx = Math.floor(relY / (slotH + slotGap));
                    this.shop_cursor = Math.max(0, Math.min(2, slotIdx));
                } else if (this.shop_tab === 3) {
                    this.shop_cursor = 0; // only 1 item (draw button)
                }
            }
            return;
        }
        if (this.state === 'play') {
            // Consumable pause menu is open
            if (this.consumable_open) {
                const cardW = 80, cardH = 120, cardGap = 10;
                const invLen = this.consumable_inv.length;
                const totalW2 = invLen * (cardW + cardGap) - cardGap;
                const startX2 = WIDTH/2 - totalW2/2;
                const cardY2 = 210;

                // Card touch
                if (y >= cardY2 && y <= cardY2 + cardH && invLen > 0) {
                    const slot = Math.floor((x - startX2) / (cardW + cardGap));
                    if (slot >= 0 && slot < invLen) {
                        this.consumable_cursor = slot;
                        this._use_consumable(slot);
                        if (this.consumable_inv.length > 0)
                            this.consumable_cursor = Math.min(this.consumable_cursor, this.consumable_inv.length - 1);
                    }
                    return;
                }

                // "ë©”ì¸ í™”ë©´ìœ¼ë¡œ" button touch (y: 470~510)
                if (y >= 470 && y <= 510 && x >= WIDTH/2 - 70 && x <= WIDTH/2 + 70) {
                    this.consumable_open = false;
                    this.state = 'menu';
                    return;
                }

                // Close button (y: 430~470)
                if (y >= 430 && y <= 470 && x >= WIDTH/2 - 60 && x <= WIDTH/2 + 60) {
                    this.consumable_open = false;
                    return;
                }

                // Tap anywhere else to close
                if (y < cardY2 - 20 || y > cardY2 + cardH + 120) {
                    this.consumable_open = false;
                }
                return;
            }

            // Consumable box button touch (y: 40 ~ 68)
            if (y >= 40 && y <= 68) {
                const boxW = 80, boxX = WIDTH/2 - boxW/2;
                if (x >= boxX && x <= boxX + boxW) {
                    this.consumable_open = true;
                    this.consumable_cursor = 0;
                    return;
                }
            }

            // Left flipper zone: left 35%
            if (x < WIDTH*0.35 && y > HEIGHT*0.5) {
                this._flipper_on('left'); return;
            }
            // Right flipper zone: right 35%
            if (x > WIDTH*0.65 && y > HEIGHT*0.5) {
                this._flipper_on('right'); return;
            }
            // Plunger zone: center bottom
            if (x > WIDTH*0.35 && x < WIDTH*0.65 && y > HEIGHT*0.75) {
                if (this.ball_in_p) {
                    this.plunger.charging = true;
                    this._plungerTouch = id;
                }
                return;
            }
            // Tilt: swipe left/right in top half
            if (y < HEIGHT*0.5 && !this.tilt_lock) {
                if (x < WIDTH*0.3) { this.tilt_x = -0.15; this.tilt_cnt++; }
                else if (x > WIDTH*0.7) { this.tilt_x = 0.15; this.tilt_cnt++; }
                if (this.tilt_cnt >= 5) { this.tilt_lock = true; this.tilt_x = 0; }
            }
        }
    }

    _handleTouchMove(x, y, id) {
        // Nothing special needed
    }

    _handleTouchEnd(x, y, id) {
        // Cancel next round hold if this touch was holding it
        if (id === this._nextRoundTouchId) {
            this._nextRoundHolding = false;
            this._nextRoundHold = 0;
            this._nextRoundTouchId = null;
        }
        if (this.state === 'play') {
            // Release flippers
            let anyLeft = false, anyRight = false;
            for (const [tid, t] of Object.entries(this._activeTouches)) {
                if (parseInt(tid) === id) continue;
                if (t.x < WIDTH*0.35 && t.y > HEIGHT*0.5) anyLeft = true;
                if (t.x > WIDTH*0.65 && t.y > HEIGHT*0.5) anyRight = true;
            }
            if (!anyLeft) this._flipper_off('left');
            if (!anyRight) this._flipper_off('right');

            // Plunger release
            if (id === this._plungerTouch) {
                if (this.ball_in_p && this.plunger.charging) {
                    for (const b of this.balls) {
                        if (Math.abs(b.x - this.plunger.x) < 20 && b.y > 700) {
                            b.vy = this.plunger.launch_speed();
                            b.vx = randUniform(-0.5, 0.5);
                        }
                    }
                    this.ball_in_p = false;
                    this.plunger.charging = false;
                    sndLaunch();
                }
                this._plungerTouch = null;
            }

            this.tilt_x = 0;
        }
    }

    _resizeCanvas() {
        const ratio = WIDTH / HEIGHT;
        let w = window.innerWidth, h = window.innerHeight;
        if (w / h > ratio) { w = h * ratio; }
        else { h = w / ratio; }
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
    }

    run() {
        this._setupTouch();
        this._resizeCanvas();
        window.addEventListener('resize', () => this._resizeCanvas());

        // Fixed 60fps timestep
        const frameDur = 1000 / FPS;
        let lastTime = performance.now();
        let accumulator = 0;

        const loop = (now) => {
            const delta = now - lastTime;
            lastTime = now;
            // Cap delta to avoid spiral of death
            accumulator += Math.min(delta, 200);

            while (accumulator >= frameDur) {
                this._update();
                if (this.state !== 'play') this.t++;
                accumulator -= frameDur;
            }

            this._draw();
            this._drawTouchControls();
            requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
    }
}

// ============================================================
//  START
// ============================================================
const game = new PinballGame();

// Query params: ?test=true&round=7&gold=100&money=50
const _urlParams = new URLSearchParams(window.location.search);
if (_urlParams.get('test') === 'true') {
    game._testRound = parseInt(_urlParams.get('round')) || 1;
    game._testGold = parseInt(_urlParams.get('gold')) || 100;
    game._testMoney = parseInt(_urlParams.get('money')) || 0;
    game._startTest();
}

game.run();

// Register Service Worker for PWA
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(() => {});
}
</script>
</body>
</html>
ë ˆ